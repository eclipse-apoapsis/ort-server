/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.workers.common.env

import org.eclipse.apoapsis.ortserver.config.Path
import org.eclipse.apoapsis.ortserver.workers.common.env.definition.GradleDefinition

/**
 * A specialized generator class to generate the content of the _init.gradle.kts_ file.
 *
 * This generator class is special because the generated file is not based on the environment definitions, but only
 * contains declarations that enable Gradle to use a central Maven mirror as configured in the admin configuration.
 * (Hence, the file is only generated if a central mirror is configured.) Since the mirror configuration actually
 * requires a rather complex script, this generator implementation uses a template file in which it only injects the
 * concrete properties of the configured mirror, such as the URL and credentials.
 *
 * TODO: It might make sense to make the template file configurable.
 *
 * See https://docs.gradle.org/current/userguide/init_scripts.html.
 */
class GradleInitGenerator : EnvironmentConfigGenerator<GradleDefinition> {
    companion object {
        /** The name of the file that is generated by this generator. */
        private const val GRADLE_INIT_SCRIPT_PATH = ".gradle/init.gradle.kts"

        /** The name of the template file used for generating the content. */
        private const val GRADLE_INIT_SCRIPT_TEMPLATE_RESOURCE_NAME = "/init.gradle.kts"

        /**
         * Replace the given [variables] in the given [template] with their current values. Return the resulting
         * plain text.
         */
        private fun replaceTemplateVariables(template: String, variables: Map<String, String?>): String =
            variables.entries.fold(template) { acc, (name, value) ->
                replaceTemplateVariable(acc, name, value)
            }

        /**
         * Replace the template variable with the given [name] in the given [template] with the provided [value].
         */
        private fun replaceTemplateVariable(template: String, name: String, value: String?): String =
            template.replace(templateVariable(name), value ?: "null")

        /**
         * Return a variable used within the template with the given [name].
         */
        private fun templateVariable(name: String): String = "#{$name}#"
    }

    override val environmentDefinitionType: Class<GradleDefinition> = GradleDefinition::class.java

    override suspend fun generate(builder: ConfigFileBuilder, definitions: Collection<GradleDefinition>) {
        builder.adminConfig.mavenCentralMirror?.let { mirror ->
            val template = javaClass.getResource(GRADLE_INIT_SCRIPT_TEMPLATE_RESOURCE_NAME).readText()

            builder.buildInUserHome(GRADLE_INIT_SCRIPT_PATH) {
                val variables = mapOf(
                    "MIRROR_URL" to mirror.url,
                    "MIRROR_USERNAME" to mirror.usernameSecret?.let {
                        """"${builder.infraSecretResolverFun(Path(it))}""""
                    },
                    "MIRROR_PASSWORD" to mirror.passwordSecret?.let {
                        """"${builder.infraSecretResolverFun(Path(it))}""""
                    }
                )

                val content = replaceTemplateVariables(template, variables)
                println(content)
            }
        }
    }
}
