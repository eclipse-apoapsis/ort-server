/*
 * Copyright (C) 2024 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services

import org.eclipse.apoapsis.ortserver.dao.QueryParametersException
import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorjob.AdvisorJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsIdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityDao
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityReferencesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.ortrun.OrtRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifierDao
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.utils.listCustomQuery
import org.eclipse.apoapsis.ortserver.dao.utils.listCustomQueryCustomOrders
import org.eclipse.apoapsis.ortserver.model.CountByCategory
import org.eclipse.apoapsis.ortserver.model.VulnerabilityRating
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithAccumulatedData
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithIdentifier
import org.eclipse.apoapsis.ortserver.model.util.ListQueryParameters
import org.eclipse.apoapsis.ortserver.model.util.ListQueryResult

import org.jetbrains.exposed.sql.Case
import org.jetbrains.exposed.sql.Count
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.ExpressionWithColumnTypeAlias
import org.jetbrains.exposed.sql.GroupConcat
import org.jetbrains.exposed.sql.IntegerColumnType
import org.jetbrains.exposed.sql.LiteralOp
import org.jetbrains.exposed.sql.Max
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.TextColumnType
import org.jetbrains.exposed.sql.UpperCase
import org.jetbrains.exposed.sql.alias
import org.jetbrains.exposed.sql.castTo
import org.jetbrains.exposed.sql.stringLiteral

/**
 * A service to interact with vulnerabilities.
 */
class VulnerabilityService(private val db: Database) {
    suspend fun listForOrtRunId(
        ortRunId: Long,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT
    ): ListQueryResult<VulnerabilityWithIdentifier> = db.dbQuery {
        val ratingAlias = ratingAlias()

        VulnerabilityDao.listCustomQuery(parameters, ResultRow::toVulnerabilityWithIdentifierAndReference) {
            VulnerabilitiesTable
                .innerJoin(AdvisorResultsVulnerabilitiesTable)
                .innerJoin(AdvisorResultsTable)
                .innerJoin(AdvisorRunsIdentifiersTable)
                .innerJoin(AdvisorRunsTable)
                .innerJoin(AdvisorJobsTable)
                .innerJoin(IdentifiersTable)
                .innerJoin(VulnerabilityReferencesTable)
                .select(VulnerabilitiesTable.columns + IdentifiersTable.columns + ratingAlias)
                .where { AdvisorJobsTable.ortRunId eq ortRunId }
                .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
        }
    }

    /**
     * List vulnerabilities found in provided ORT runs
     */
    suspend fun listForOrtRuns(
        ortRunIds: List<Long>,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT
    ): ListQueryResult<VulnerabilityWithAccumulatedData> = db.dbQuery {
        val runIdsAlias = runIdsAlias()
        val repositoriesCountAlias = repositoriesCountAlias()
        val ratingAlias = ratingAlias()

        val orders = parameters.sortFields.map {
            val sortOrder = it.direction.toSortOrder()
            when (it.name) {
                "rating" -> ratingAlias to sortOrder
                "repositoriesCount" -> repositoriesCountAlias to sortOrder
                "externalId" -> VulnerabilitiesTable.externalId to sortOrder
                "identifierType" -> IdentifiersTable.type to sortOrder
                "identifierNamespace" -> IdentifiersTable.namespace to sortOrder
                "identifierName" -> IdentifiersTable.name to sortOrder
                "identifierVersion" -> IdentifiersTable.version to sortOrder
                else -> throw QueryParametersException("Unsupported field for sorting: '${it.name}'.")
            }
        }

        listCustomQueryCustomOrders(parameters, orders, ResultRow::toVulnerabilityWithAccumulatedData) {
            VulnerabilitiesTable
                .innerJoin(AdvisorResultsVulnerabilitiesTable)
                .innerJoin(AdvisorResultsTable)
                .innerJoin(AdvisorRunsIdentifiersTable)
                .innerJoin(AdvisorRunsTable)
                .innerJoin(AdvisorJobsTable)
                .innerJoin(OrtRunsTable)
                .innerJoin(RepositoriesTable)
                .innerJoin(IdentifiersTable)
                .innerJoin(VulnerabilityReferencesTable)
                .select(
                    VulnerabilitiesTable.columns +
                            IdentifiersTable.columns +
                            ratingAlias +
                            runIdsAlias +
                            repositoriesCountAlias
                )
                .where { OrtRunsTable.id inList ortRunIds }
                .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
        }
    }

    /** Count vulnerabilities found in provided ORT runs. */
    suspend fun countForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count vulnerabilities by rating in provided ORT runs. */
    suspend fun countByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> = db.dbQuery {
        val countAlias = Count(stringLiteral("*")).alias("count")
        val ratingAlias = ratingAlias()

        val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(VulnerabilitiesTable.id, ratingAlias)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .alias("subQuery")

        val rating = subQuery[ratingAlias]

        subQuery
            .select(rating, countAlias)
            .groupBy(rating)
            .forEach { row ->
                ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
            }

        CountByCategory(ratingToCountMap)
    }
}

/** Alias for determining an advisory overall rating of a vulnerability based on its individual references. */
private fun ratingAlias(): ExpressionWithColumnTypeAlias<Int?> {
    val severityCase = Case()
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "CRITICAL", LiteralOp(IntegerColumnType(), 4))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "HIGH", LiteralOp(IntegerColumnType(), 3))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "MEDIUM", LiteralOp(IntegerColumnType(), 2))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "LOW", LiteralOp(IntegerColumnType(), 1))
        .Else(LiteralOp(IntegerColumnType(), 0))

    return Max(severityCase, IntegerColumnType()).alias("rating")
}

/** Alias for gathering the IDs of the runs where the vulnerability was found in. */
private fun runIdsAlias() = GroupConcat(
    OrtRunsTable.id.castTo(TextColumnType()),
    ",",
    true
).alias("runIds")

/** Alias to return the count for the repositories that the vulnerability was found in. */
private fun repositoriesCountAlias() = Count(
    RepositoriesTable.id,
    true
).alias("repositoriesCount")

private fun ResultRow.toVulnerabilityWithAccumulatedData() = VulnerabilityWithAccumulatedData(
    vulnerability = VulnerabilityDao.wrapRow(this).mapToModel(),
    identifier = IdentifierDao.wrapRow(this).mapToModel(),
    rating = VulnerabilityRating.entries[(this[ratingAlias()] ?: 0)],
    ortRunIds = this[runIdsAlias()].split(",").map { it.toLong() },
    repositoriesCount = this[repositoriesCountAlias()]
)

private fun ResultRow.toVulnerabilityWithIdentifierAndReference() = VulnerabilityWithIdentifier(
    vulnerability = VulnerabilityDao.wrapRow(this).mapToModel(),
    identifier = IdentifierDao.wrapRow(this).mapToModel(),
    rating = VulnerabilityRating.entries[this[ratingAlias()] ?: 0]
)
