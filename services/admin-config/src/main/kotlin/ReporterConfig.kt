/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services.config

/**
 * A class defining an asset (such as a font or an image) which is required to generate a report.
 *
 * The Reporter can be configured to download specific assets from the configuration before starting the report
 * generation. That way it is ensured that files referenced from reporter templates are actually available locally at
 * the expected relative paths.
 *
 * A [ReporterAsset] can be a single file or a directory. In the latter case, all files contained in the directory are
 * downloaded.
 */
data class ReporterAsset(
    /**
     * The source path of this asset in the configuration. This path is passed to the configuration manager to download
     * this asset.
     */
    val sourcePath: String,

    /**
     * A path (relative to the location of reporter template files) where this asset should be placed. Typically,
     * assets are referenced via relative paths from reporter templates, e.g. _./images/logo.png_. Using this
     * property, such a relative path can be specified. If it is `null`, the root folder of the reporter worker
     * (which also contains the downloaded templates) is used.
     */
    val targetFolder: String? = null,

    /**
     * An optional name for the downloaded asset. This property can be used to rename the asset file or folder locally.
     * If it is undefined, the original name (determined from the last path component of [sourcePath]) is used.
     */
    val targetName: String? = null
)

/**
 * A class that can be used to configure the names under which reports are stored.
 *
 * Per default, the names of reports are determined by the reporters that produce these reports. This may not always
 * be desired, especially if names are constructed dynamically based on some conventions. This class can be used to
 * override the default names used by reporters. The reporter configuration contains a map that assigns each report
 * type an optional instance of this class. The configuration contained in this instance is then used to generate the
 * names for reports.
 */
data class ReportNameMapping(
    /**
     * A name prefix for constructing report names. The names of all reports generated by a reporter will start with
     * this prefix and use the original file extensions. In case there are multiple reports, indices are added
     * according to the further properties of this class.
     */
    val namePrefix: String,

    /**
     * The index to be used for the first report generated by a reporter. If there are multiple reports, their names
     * are derived from [namePrefix] plus a sequential index starting with this value, such as "report-1.html",
     * "report-2.html", etc.
     */
    val startIndex: Int = 1,

    /**
     * A flag that determines whether the name of reports should always contain an index. The flag has only an effect
     * if there is only a single report. If it is *false*, the report is named by the [namePrefix] plus the original
     * file extension. If it is *true*, the [startIndex] is appended to the [namePrefix].
     */
    val alwaysAppendIndex: Boolean = false
)

/**
 * A data class defining a report that is supported by an ORT Server instance. An instance specifies the concrete
 * reporter plugin to generate this report. It also allows declaring assets that must be obtained before starting the
 * report generation.
 */
data class ReportDefinition(
    /**
     * The ID of the reporter plugin that generates this report.
     */
    val pluginId: String,

    /**
     * A list with [ReporterAsset]s pointing to files that must be downloaded before the generation of this report is
     * started.
     */
    val assetFiles: List<ReporterAsset> = emptyList(),

    /**
     * A list with [ReporterAsset]s pointing to directories that must be downloaded before the generation of this
     * report is started. This is analogous to [assetFiles], but all the files contained in the specified directory are
     * downloaded.
     */
    val assetDirectories: List<ReporterAsset> = emptyList(),

    /**
     * An optional name mapping for this report type. This can be used to override the default names of the files
     * generated by this report.
     */
    val nameMapping: ReportNameMapping? = null
)

/**
 * A type definition for a [Map] of named [ReporterAsset]s. In the [ReporterConfig], it is possible to define groups of
 * asset files and directories that can then be referenced from report definitions by their name. This reduces
 * redundancy in definitions and also allows selecting assets dynamically.
 */
typealias GlobalReporterAssets = Map<String, List<ReporterAsset>>

/**
 * A data class that represents the configuration of the Reporter worker.
 *
 * An instance of this class is part of the [AdminConfig]. It defines the reports users can request from this ORT
 * Server instance, together with some other configuration options required during report generation.
 *
 * When it comes to report generation, ORT Server follows a slightly different approach than ORT. ORT's reporter
 * plugins are rather technical and focus on the concrete output format. For instance, in order to generate a
 * disclosure document in PDF format, one has to select the PDF reporter plugin and specify a template for the
 * disclosure report. ORT Server in contrast allows defining a "PDF disclosure document" report, which under the hood
 * maps to the PDF reporter plugin. This is the purpose of the [ReportDefinition] objects managed by this class.
 */
data class ReporterConfig(
    /**
     * A [Map] containing the definitions of all reports supported by this ORT Server instance. The keys are the logic
     * names under which the reports can be accessed.
     */
    private val reportDefinitionsMap: Map<String, ReportDefinition>,

    /**
     * The path to the how-to-fix Kotlin script which is resolved from the configuration source. This Kotlin script
     * will be used to instantiate an instance of HowToFixTextProvider, which injects how-to-fix texts for ORT issues.
     */
    val howToFixTextProviderFile: String,

    /**
     * An optional path to a configuration directory containing custom license texts. If defined, all files from this
     * directory are downloaded and made available via a `DefaultLicenseTextProvider` instance.
     */
    val customLicenseTextDir: String? = null,

    /**
     * A [Map] with global [ReporterAsset]s that can be referenced from report definitions.
     */
    val globalAssets: GlobalReporterAssets = emptyMap()
) {
    /**
     * A [Map] with the existing report definitions using lowercase names as keys. This is used to simplify
     * case-insensitive lookups of report definitions by name.
     */
    private val lowercaseReportDefinitions = reportDefinitionsMap.mapKeys { it.key.lowercase() }

    /** A set with the names of all existing report definitions. */
    val reportDefinitionNames: Set<String>
        get() = reportDefinitionsMap.keys

    /** A collection of all existing report definitions. */
    val reportDefinitions: Collection<ReportDefinition>
        get() = reportDefinitionsMap.values

    /**
     * Return the [ReportDefinition] for the report with the given [name] or *null* if no such report is defined. The
     * names of report definitions are case-insensitive.
     */
    fun getReportDefinition(name: String): ReportDefinition? =
        lowercaseReportDefinitions[name.lowercase()]
}
