/*
 * Copyright (C) 2024 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services.ortrun

import org.eclipse.apoapsis.ortserver.dao.QueryParametersException
import org.eclipse.apoapsis.ortserver.dao.blockingQuery
import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorjob.AdvisorJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsIdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.ResolvedVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityDao
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityReferencesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerjob.AnalyzerJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.AnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesAnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.ortrun.OrtRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationDataTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.VulnerabilityResolutionsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedConfigurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationProvidersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifierDao
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.utils.applyILike
import org.eclipse.apoapsis.ortserver.model.CountByCategory
import org.eclipse.apoapsis.ortserver.model.VulnerabilityFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityForRunsFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityRating
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithAccumulatedData
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithDetails
import org.eclipse.apoapsis.ortserver.model.runs.Identifier
import org.eclipse.apoapsis.ortserver.model.runs.advisor.AdvisorDetails
import org.eclipse.apoapsis.ortserver.model.runs.advisor.Vulnerability
import org.eclipse.apoapsis.ortserver.model.runs.advisor.VulnerabilityReference
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolution
import org.eclipse.apoapsis.ortserver.model.util.ComparisonOperator
import org.eclipse.apoapsis.ortserver.model.util.ListQueryParameters
import org.eclipse.apoapsis.ortserver.model.util.ListQueryResult
import org.eclipse.apoapsis.ortserver.model.util.OrderDirection
import org.eclipse.apoapsis.ortserver.model.util.OrderField
import org.eclipse.apoapsis.ortserver.services.ResourceNotFoundException
import org.eclipse.apoapsis.ortserver.services.utils.toSortOrder

import org.jetbrains.exposed.v1.core.Case
import org.jetbrains.exposed.v1.core.Count
import org.jetbrains.exposed.v1.core.CustomFunction
import org.jetbrains.exposed.v1.core.Expression
import org.jetbrains.exposed.v1.core.ExpressionWithColumnTypeAlias
import org.jetbrains.exposed.v1.core.GroupConcat
import org.jetbrains.exposed.v1.core.IntegerColumnType
import org.jetbrains.exposed.v1.core.JoinType
import org.jetbrains.exposed.v1.core.LiteralOp
import org.jetbrains.exposed.v1.core.Max
import org.jetbrains.exposed.v1.core.Op
import org.jetbrains.exposed.v1.core.ResultRow
import org.jetbrains.exposed.v1.core.SortOrder
import org.jetbrains.exposed.v1.core.TextColumnType
import org.jetbrains.exposed.v1.core.UpperCase
import org.jetbrains.exposed.v1.core.alias
import org.jetbrains.exposed.v1.core.and
import org.jetbrains.exposed.v1.core.castTo
import org.jetbrains.exposed.v1.core.concat
import org.jetbrains.exposed.v1.core.eq
import org.jetbrains.exposed.v1.core.inList
import org.jetbrains.exposed.v1.core.innerJoin
import org.jetbrains.exposed.v1.core.isNotNull
import org.jetbrains.exposed.v1.core.neq
import org.jetbrains.exposed.v1.core.not
import org.jetbrains.exposed.v1.core.notExists
import org.jetbrains.exposed.v1.core.notInList
import org.jetbrains.exposed.v1.core.or
import org.jetbrains.exposed.v1.core.stringLiteral
import org.jetbrains.exposed.v1.core.wrapAsExpression
import org.jetbrains.exposed.v1.jdbc.Database
import org.jetbrains.exposed.v1.jdbc.Query
import org.jetbrains.exposed.v1.jdbc.andWhere
import org.jetbrains.exposed.v1.jdbc.select

/**
 * A service to interact with vulnerabilities.
 */
class VulnerabilityService(private val db: Database, private val ortRunService: OrtRunService) {
    fun listForOrtRunId(
        ortRunId: Long,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        vulnerabilityFilters: VulnerabilityFilters = VulnerabilityFilters()
    ): ListQueryResult<VulnerabilityWithDetails> {
        ortRunService.getOrtRun(ortRunId) ?: throw ResourceNotFoundException(
            "ORT run with ID $ortRunId not found."
        )

        return db.blockingQuery {
            val (query, ratingAlias) = buildListForOrtRunIdQuery(ortRunId, vulnerabilityFilters)

            val totalCount = query.count()
            val pagedRows = fetchPagedVulnerabilityRows(query, ratingAlias, parameters)

            if (pagedRows.isEmpty()) {
                return@blockingQuery ListQueryResult(emptyList(), parameters, totalCount)
            }

            val vulnerabilityIds = pagedRows.map { it.vulnerabilityId }.distinct()
            val identifierIds = pagedRows.map { it.identifierId }.distinct()
            val vulnerabilityIdentifierPairs = pagedRows
                .map { it.vulnerabilityId to it.identifierId }
                .distinct()

            val vulnerabilityReferencesById = fetchVulnerabilityReferencesById(vulnerabilityIds)
            val vulnerabilityRowsById = fetchVulnerabilityRowsById(vulnerabilityIds)
            val resolutionsByVulnerabilityAndIdentifier = fetchResolutionsByVulnerabilityAndIdentifier(
                ortRunId,
                vulnerabilityIdentifierPairs
            )
            val identifierRowsById = fetchIdentifierRowsById(identifierIds)
            val purlByIdentifierId = getPurlByIdentifierIdForOrtRun(ortRunId, identifierIds)
            val vulnerabilities = assembleVulnerabilitiesWithDetails(
                pagedRows,
                vulnerabilityReferencesById,
                vulnerabilityRowsById,
                resolutionsByVulnerabilityAndIdentifier,
                identifierRowsById,
                purlByIdentifierId
            )

            ListQueryResult(data = vulnerabilities, params = parameters, totalCount = totalCount)
        }
    }

    private fun buildListForOrtRunIdQuery(
        ortRunId: Long,
        vulnerabilityFilters: VulnerabilityFilters
    ): Pair<Query, ExpressionWithColumnTypeAlias<Int?>> {
        val ratingAlias = ratingAlias()

        val baseJoin = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .join(
                VulnerabilityReferencesTable,
                JoinType.LEFT,
                VulnerabilitiesTable.id,
                VulnerabilityReferencesTable.vulnerabilityId
            )

        val query = baseJoin
            .select(
                VulnerabilitiesTable.id,
                IdentifiersTable.id,
                AdvisorResultsTable.advisorName,
                ratingAlias
            )
            .where { AdvisorJobsTable.ortRunId eq ortRunId }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, AdvisorResultsTable.advisorName)

        val resolutionExistsSubquery = ResolvedVulnerabilitiesTable
            .select(ResolvedVulnerabilitiesTable.id)
            .where {
                (ResolvedVulnerabilitiesTable.ortRunId eq ortRunId) and
                    (ResolvedVulnerabilitiesTable.vulnerabilityId eq VulnerabilitiesTable.id) and
                    (ResolvedVulnerabilitiesTable.identifierId eq IdentifiersTable.id)
            }

        when (vulnerabilityFilters.resolved) {
            true -> query.andWhere { not(notExists(resolutionExistsSubquery)) }
            false -> query.andWhere { notExists(resolutionExistsSubquery) }
            null -> {}
        }

        return query to ratingAlias
    }

    private fun fetchPagedVulnerabilityRows(
        query: Query,
        ratingAlias: ExpressionWithColumnTypeAlias<Int?>,
        parameters: ListQueryParameters
    ): List<PagedVulnerabilityRow> {
        val sortFields = parameters.sortFields.ifEmpty {
            listOf(OrderField("externalId", OrderDirection.ASCENDING))
        }

        sortFields.forEach { orderField ->
            val sortOrder = orderField.direction.toSortOrder()

            when (orderField.name) {
                "externalId" -> query.orderBy(VulnerabilitiesTable.externalId to sortOrder)
                else -> throw QueryParametersException("Unsupported field for sorting: '${orderField.name}'.")
            }
        }

        query.orderBy(VulnerabilitiesTable.id to SortOrder.ASC)
        query.orderBy(IdentifiersTable.id to SortOrder.ASC)
        query.orderBy(AdvisorResultsTable.advisorName to SortOrder.ASC)

        query.limit(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT).offset(parameters.offset ?: 0L)

        return query.map { row ->
            PagedVulnerabilityRow(
                vulnerabilityId = row[VulnerabilitiesTable.id].value,
                identifierId = row[IdentifiersTable.id].value,
                advisorName = row[AdvisorResultsTable.advisorName],
                ratingOrdinal = row.getOrNull(ratingAlias) ?: VulnerabilityRating.NONE.ordinal
            )
        }
    }

    private fun fetchVulnerabilityReferencesById(
        vulnerabilityIds: List<Long>
    ): Map<Long, List<VulnerabilityReference>> =
        VulnerabilityReferencesTable
            .select(
                VulnerabilityReferencesTable.vulnerabilityId,
                VulnerabilityReferencesTable.id,
                VulnerabilityReferencesTable.url,
                VulnerabilityReferencesTable.scoringSystem,
                VulnerabilityReferencesTable.severity,
                VulnerabilityReferencesTable.score,
                VulnerabilityReferencesTable.vector
            )
            .where { VulnerabilityReferencesTable.vulnerabilityId inList vulnerabilityIds }
            .orderBy(VulnerabilityReferencesTable.vulnerabilityId to SortOrder.ASC)
            .orderBy(VulnerabilityReferencesTable.id to SortOrder.ASC)
            .groupBy { it[VulnerabilityReferencesTable.vulnerabilityId].value }
            .mapValues { (_, rows) ->
                rows.map { row ->
                    VulnerabilityReference(
                        url = row[VulnerabilityReferencesTable.url],
                        scoringSystem = row[VulnerabilityReferencesTable.scoringSystem],
                        severity = row[VulnerabilityReferencesTable.severity],
                        score = row[VulnerabilityReferencesTable.score],
                        vector = row[VulnerabilityReferencesTable.vector]
                    )
                }
            }

    private fun fetchVulnerabilityRowsById(vulnerabilityIds: List<Long>): Map<Long, ResultRow> =
        VulnerabilitiesTable
            .select(
                VulnerabilitiesTable.id,
                VulnerabilitiesTable.externalId,
                VulnerabilitiesTable.summary,
                VulnerabilitiesTable.description
            )
            .where { VulnerabilitiesTable.id inList vulnerabilityIds }
            .associateBy { it[VulnerabilitiesTable.id].value }

    private fun fetchResolutionsByVulnerabilityAndIdentifier(
        ortRunId: Long,
        vulnerabilityIdentifierPairs: List<Pair<Long, Long>>
    ): Map<Pair<Long, Long>, List<VulnerabilityResolution>> {
        if (vulnerabilityIdentifierPairs.isEmpty()) return emptyMap()

        val pairCondition = vulnerabilityIdentifierPairs
            .map { (vulnerabilityId, identifierId) ->
                (ResolvedVulnerabilitiesTable.vulnerabilityId eq vulnerabilityId) and
                    (ResolvedVulnerabilitiesTable.identifierId eq identifierId)
            }
            .reduce { accumulator, op -> accumulator or op }

        return ResolvedVulnerabilitiesTable
            .innerJoin(VulnerabilityResolutionsTable, { vulnerabilityResolutionId }, { id })
            .select(
                ResolvedVulnerabilitiesTable.vulnerabilityId,
                ResolvedVulnerabilitiesTable.identifierId,
                VulnerabilityResolutionsTable.externalId,
                VulnerabilityResolutionsTable.reason,
                VulnerabilityResolutionsTable.comment
            )
            .where {
                (ResolvedVulnerabilitiesTable.ortRunId eq ortRunId) and
                    pairCondition
            }
            .groupBy(
                {
                    it[ResolvedVulnerabilitiesTable.vulnerabilityId].value to
                        it[ResolvedVulnerabilitiesTable.identifierId].value
                },
                {
                    VulnerabilityResolution(
                        externalId = it[VulnerabilityResolutionsTable.externalId],
                        reason = it[VulnerabilityResolutionsTable.reason],
                        comment = it[VulnerabilityResolutionsTable.comment]
                    )
                }
            )
    }

    private fun fetchIdentifierRowsById(identifierIds: List<Long>): Map<Long, ResultRow> =
        IdentifiersTable
            .select(
                IdentifiersTable.id,
                IdentifiersTable.type,
                IdentifiersTable.namespace,
                IdentifiersTable.name,
                IdentifiersTable.version
            )
            .where { IdentifiersTable.id inList identifierIds }
            .associateBy { it[IdentifiersTable.id].value }

    private fun assembleVulnerabilitiesWithDetails(
        pagedRows: List<PagedVulnerabilityRow>,
        vulnerabilityReferencesById: Map<Long, List<VulnerabilityReference>>,
        vulnerabilityRowsById: Map<Long, ResultRow>,
        resolutionsByVulnerabilityAndIdentifier: Map<Pair<Long, Long>, List<VulnerabilityResolution>>,
        identifierRowsById: Map<Long, ResultRow>,
        purlByIdentifierId: Map<Long, String>
    ): List<VulnerabilityWithDetails> =
        pagedRows.map { pagedRow ->
            val vulnerabilityRow = requireNotNull(vulnerabilityRowsById[pagedRow.vulnerabilityId]) {
                "Could not find vulnerability with ID ${pagedRow.vulnerabilityId}."
            }
            val identifierRow = requireNotNull(identifierRowsById[pagedRow.identifierId]) {
                "Could not find identifier with ID ${pagedRow.identifierId}."
            }

            val identifier = Identifier(
                type = identifierRow[IdentifiersTable.type],
                namespace = identifierRow[IdentifiersTable.namespace],
                name = identifierRow[IdentifiersTable.name],
                version = identifierRow[IdentifiersTable.version]
            )

            VulnerabilityWithDetails(
                vulnerability = Vulnerability(
                    externalId = vulnerabilityRow[VulnerabilitiesTable.externalId],
                    summary = vulnerabilityRow[VulnerabilitiesTable.summary],
                    description = vulnerabilityRow[VulnerabilitiesTable.description],
                    references = vulnerabilityReferencesById[pagedRow.vulnerabilityId].orEmpty()
                ),
                identifier = identifier,
                rating = VulnerabilityRating.entries.getOrElse(pagedRow.ratingOrdinal) { VulnerabilityRating.NONE },
                resolutions = resolutionsByVulnerabilityAndIdentifier[
                    pagedRow.vulnerabilityId to pagedRow.identifierId
                ].orEmpty(),
                advisor = AdvisorDetails(name = pagedRow.advisorName),
                purl = purlByIdentifierId[pagedRow.identifierId] ?: identifier.toFallbackPurl()
            )
        }

    /**
     * List vulnerabilities found in provided ORT runs
     */
    suspend fun listForOrtRuns(
        ortRunIds: List<Long>,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        filters: VulnerabilityForRunsFilters = VulnerabilityForRunsFilters()
    ): ListQueryResult<VulnerabilityWithAccumulatedData> = db.dbQuery {
        val runIdsAlias = runIdsAlias()
        val repositoriesCountAlias = repositoriesCountAlias()
        val ratingAlias = ratingAlias()

        val curatedPurlSubquery = PackageCurationDataTable
            .innerJoin(PackageCurationsTable)
            .innerJoin(ResolvedPackageCurationsTable)
            .innerJoin(ResolvedPackageCurationProvidersTable)
            .innerJoin(ResolvedConfigurationsTable)
            .select(PackageCurationDataTable.purl)
            .where {
                (ResolvedConfigurationsTable.ortRunId eq OrtRunsTable.id) and (
                    PackageCurationsTable.identifierId eq
                    IdentifiersTable.id
                ) and (PackageCurationDataTable.purl.isNotNull())
            }
            .orderBy(ResolvedPackageCurationProvidersTable.rank)
            .orderBy(ResolvedPackageCurationsTable.rank)
            .limit(1)

        val curatedPurlExpression: Expression<String?> = wrapAsExpression(curatedPurlSubquery)

        val purlAlias = CustomFunction(
            "COALESCE",
            PackagesTable.purl.columnType,
            curatedPurlExpression,
            PackagesTable.purl
        ).alias("purl")

        val vulnerabilityIdAlias = VulnerabilitiesTable.id.alias("vulnerability_id")
        val identifierIdAlias = IdentifiersTable.id.alias("identifier_id")
        val ortRunIdAlias = OrtRunsTable.id.alias("ort_run_id")

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(OrtRunsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(AnalyzerJobsTable)
            .innerJoin(AnalyzerRunsTable)
            .innerJoin(PackagesAnalyzerRunsTable)
            .innerJoin(PackagesTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(vulnerabilityIdAlias, identifierIdAlias, ortRunIdAlias, purlAlias, ratingAlias)
            .where { OrtRunsTable.id inList ortRunIds }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlAlias, OrtRunsTable.id)
            .alias("subquery")

        val purlColumn = subQuery[purlAlias]
        val vulnerabilityIdColumn = subQuery[vulnerabilityIdAlias]
        val identifierIdColumn = subQuery[identifierIdAlias]
        val ortRunIdColumn = subQuery[ortRunIdAlias]
        val ratingColumn = subQuery[ratingAlias]

        val maxRatingAlias = Max(ratingColumn, IntegerColumnType()).alias("maxRating")

        val query = subQuery
            .innerJoin(VulnerabilitiesTable, { vulnerabilityIdColumn }, { VulnerabilitiesTable.id })
            .innerJoin(IdentifiersTable, { identifierIdColumn }, { IdentifiersTable.id })
            .innerJoin(OrtRunsTable, { ortRunIdColumn }, { OrtRunsTable.id })
            .innerJoin(RepositoriesTable)
            .select(
                VulnerabilitiesTable.columns + IdentifiersTable.columns + maxRatingAlias + runIdsAlias +
                        repositoriesCountAlias + purlColumn
            )
            .where {
                var condition: Op<Boolean> = Op.TRUE

                filters.rating?.let {
                    val ratingsAsInt = it.value.map { severity -> severity.ordinal }
                    condition = condition and when (it.operator) {
                        ComparisonOperator.IN -> ratingColumn inList ratingsAsInt
                        else -> ratingColumn notInList ratingsAsInt
                    }
                }

                filters.identifier?.let {
                    val namespaceWithSlash = Case()
                        .When(
                            IdentifiersTable.namespace neq stringLiteral(""),
                            concat(IdentifiersTable.namespace, stringLiteral("/"))
                        )
                        .Else(stringLiteral(":"))

                    val concatenatedIdentifier = concat(
                        IdentifiersTable.type,
                        stringLiteral(":"),
                        namespaceWithSlash,
                        IdentifiersTable.name,
                        stringLiteral("@"),
                        IdentifiersTable.version
                    )

                    condition = condition and concatenatedIdentifier.applyILike(it.value)
                }

                filters.purl?.let {
                    condition = condition and purlColumn.applyILike(it.value)
                }

                filters.externalId?.let {
                    condition = condition and VulnerabilitiesTable.externalId.applyILike(it.value)
                }

                condition
            }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlColumn)

        val orders = mutableListOf<Pair<Expression<*>, SortOrder>>()

        parameters.sortFields.forEach {
            val sortOrder = it.direction.toSortOrder()
            when (it.name) {
                "rating" -> orders += maxRatingAlias to sortOrder

                "repositoriesCount" -> orders += repositoriesCountAlias to sortOrder

                "externalId" -> orders += VulnerabilitiesTable.externalId to sortOrder

                "identifier" -> {
                    orders += IdentifiersTable.type to sortOrder
                    orders += IdentifiersTable.namespace to sortOrder
                    orders += IdentifiersTable.name to sortOrder
                    orders += IdentifiersTable.version to sortOrder
                }

                "purl" -> {
                    orders += purlColumn to sortOrder
                }

                else -> throw QueryParametersException("Unsupported field for sorting: '${it.name}'.")
            }
        }

        val totalCount = query.count()

        val vulnerabilities = query
            .orderBy(*orders.toTypedArray())
            .limit(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)
            .offset(parameters.offset ?: 0)
            .map { row ->
                VulnerabilityWithAccumulatedData(
                    vulnerability = VulnerabilityDao.wrapRow(row).mapToModel(),
                    identifier = IdentifierDao.wrapRow(row).mapToModel(),
                    purl = row[purlColumn],
                    rating = VulnerabilityRating.entries[(row[maxRatingAlias] ?: 0)],
                    ortRunIds = row[runIdsAlias].split(",").map { it.toLong() },
                    repositoriesCount = row[repositoriesCountAlias]
                )
            }

        ListQueryResult(vulnerabilities, parameters, totalCount)
    }

    /** Count vulnerabilities found in provided ORT runs. */
    suspend fun countForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count vulnerabilities by rating in provided ORT runs. */
    suspend fun countByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> = db.dbQuery {
        val countAlias = Count(stringLiteral("*")).alias("count")
        val ratingAlias = ratingAlias()

        val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(VulnerabilitiesTable.id, ratingAlias)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .alias("subQuery")

        val rating = subQuery[ratingAlias]

        subQuery
            .select(rating, countAlias)
            .groupBy(rating)
            .forEach { row ->
                ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
            }

        CountByCategory(ratingToCountMap)
    }

    /** Count unresolved vulnerabilities found in provided ORT runs. */
    suspend fun countUnresolvedForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where {
                (AdvisorJobsTable.ortRunId inList ortRunIds.asList()) and
                    notExists(
                        ResolvedVulnerabilitiesTable
                            .select(ResolvedVulnerabilitiesTable.id)
                            .where {
                                (ResolvedVulnerabilitiesTable.ortRunId inList ortRunIds.asList()) and
                                    (ResolvedVulnerabilitiesTable.vulnerabilityId eq VulnerabilitiesTable.id) and
                                    (ResolvedVulnerabilitiesTable.identifierId eq IdentifiersTable.id)
                            }
                    )
            }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count unresolved vulnerabilities by rating for provided ORT runs. */
    suspend fun countUnresolvedByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> =
        db.dbQuery {
            val countAlias = Count(stringLiteral("*")).alias("count")
            val ratingAlias = ratingAlias()

            val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

            val subQuery = VulnerabilitiesTable
                .innerJoin(AdvisorResultsVulnerabilitiesTable)
                .innerJoin(AdvisorResultsTable)
                .innerJoin(AdvisorRunsIdentifiersTable)
                .innerJoin(AdvisorRunsTable)
                .innerJoin(AdvisorJobsTable)
                .innerJoin(IdentifiersTable)
                .innerJoin(VulnerabilityReferencesTable)
                .select(VulnerabilitiesTable.id, ratingAlias)
                .where {
                    (AdvisorJobsTable.ortRunId inList ortRunIds.asList()) and
                        notExists(
                            ResolvedVulnerabilitiesTable
                                .select(ResolvedVulnerabilitiesTable.id)
                                .where {
                                    (ResolvedVulnerabilitiesTable.ortRunId inList ortRunIds.asList()) and
                                        (ResolvedVulnerabilitiesTable.vulnerabilityId eq VulnerabilitiesTable.id) and
                                        (ResolvedVulnerabilitiesTable.identifierId eq IdentifiersTable.id)
                                }
                        )
                }
                .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
                .alias("subQuery")

            val rating = subQuery[ratingAlias]

            subQuery
                .select(rating, countAlias)
                .groupBy(rating)
                .forEach { row ->
                    ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
                }

            CountByCategory(ratingToCountMap)
        }
}

private data class PagedVulnerabilityRow(
    val vulnerabilityId: Long,
    val identifierId: Long,
    val advisorName: String,
    val ratingOrdinal: Int
)

/** Alias for determining an advisory overall rating of a vulnerability based on its individual references. */
private fun ratingAlias(): ExpressionWithColumnTypeAlias<Int?> {
    val severityCase = Case()
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "CRITICAL", LiteralOp(IntegerColumnType(), 4))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "HIGH", LiteralOp(IntegerColumnType(), 3))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "MEDIUM", LiteralOp(IntegerColumnType(), 2))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "LOW", LiteralOp(IntegerColumnType(), 1))
        .Else(LiteralOp(IntegerColumnType(), 0))

    return Max(severityCase, IntegerColumnType()).alias("rating")
}

/** Alias for gathering the IDs of the runs where the vulnerability was found in. */
private fun runIdsAlias() = GroupConcat(
    OrtRunsTable.id.castTo(TextColumnType()),
    ",",
    true
).alias("runIds")

/** Alias to return the count for the repositories that the vulnerability was found in. */
private fun repositoriesCountAlias() = Count(
    RepositoriesTable.id,
    true
).alias("repositoriesCount")

/**
 * Build a purl string from an [Identifier], used as fallback if no analyzer package data exists.
 */
private fun Identifier.toFallbackPurl(): String = buildString {
    append("pkg:")
    append(type.lowercase())
    append("/")

    if (namespace.isNotBlank()) {
        append(namespace)
        append("/")
    }

    append(name)
    append("@")
    append(version)
}
