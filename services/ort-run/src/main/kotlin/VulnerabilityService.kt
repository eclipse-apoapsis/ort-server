/*
 * Copyright (C) 2024 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services.ortrun

import org.eclipse.apoapsis.ortserver.dao.QueryParametersException
import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorjob.AdvisorJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsIdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityDao
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityReferencesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerjob.AnalyzerJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.AnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesAnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.ortrun.OrtRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationDataTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.RepositoryConfigurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.RepositoryConfigurationsVulnerabilityResolutionsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.VulnerabilityResolutionsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedConfigurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationProvidersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.tables.VulnerabilityResolutionDefinitionsTable
import org.eclipse.apoapsis.ortserver.dao.tables.VulnerabilityResolutionDefinitionsTable.toVulnerabilityResolutionDefinition
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifierDao
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.utils.applyILike
import org.eclipse.apoapsis.ortserver.model.AppliedVulnerabilityResolution
import org.eclipse.apoapsis.ortserver.model.CountByCategory
import org.eclipse.apoapsis.ortserver.model.VulnerabilityFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityForRunsFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityRating
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithAccumulatedData
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithDetails
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolution as ModelVulnerabilityResolution
import org.eclipse.apoapsis.ortserver.model.util.ComparisonOperator
import org.eclipse.apoapsis.ortserver.model.util.ListQueryParameters
import org.eclipse.apoapsis.ortserver.model.util.ListQueryResult
import org.eclipse.apoapsis.ortserver.model.util.OrderDirection
import org.eclipse.apoapsis.ortserver.services.ResourceNotFoundException
import org.eclipse.apoapsis.ortserver.services.utils.toSortOrder

import org.jetbrains.exposed.sql.Case
import org.jetbrains.exposed.sql.Count
import org.jetbrains.exposed.sql.CustomFunction
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.Expression
import org.jetbrains.exposed.sql.ExpressionWithColumnTypeAlias
import org.jetbrains.exposed.sql.GroupConcat
import org.jetbrains.exposed.sql.IntegerColumnType
import org.jetbrains.exposed.sql.LiteralOp
import org.jetbrains.exposed.sql.Max
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.TextColumnType
import org.jetbrains.exposed.sql.UpperCase
import org.jetbrains.exposed.sql.alias
import org.jetbrains.exposed.sql.and
import org.jetbrains.exposed.sql.castTo
import org.jetbrains.exposed.sql.innerJoin
import org.jetbrains.exposed.sql.stringLiteral
import org.jetbrains.exposed.sql.wrapAsExpression

import org.ossreviewtoolkit.model.config.VulnerabilityResolution
import org.ossreviewtoolkit.model.config.VulnerabilityResolutionReason
import org.ossreviewtoolkit.model.utils.toPurl

/**
 * A service to interact with vulnerabilities.
 */
class VulnerabilityService(private val db: Database, private val ortRunService: OrtRunService) {
    suspend fun listForOrtRunId(
        ortRunId: Long,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        vulnerabilityFilters: VulnerabilityFilters = VulnerabilityFilters()
    ): ListQueryResult<VulnerabilityWithDetails> {
        val ortRun = ortRunService.getOrtRun(ortRunId) ?: throw ResourceNotFoundException(
            "ORT run with ID $ortRunId not found."
        )

        val ortResult = ortRunService.generateOrtResult(
            ortRun,
            loadAdvisorRun = true, // Only interested in vulnerabilities (advisor).
            loadScannerRun = false,
            loadEvaluatorRun = false,
            failIfRepoInfoMissing = false
        )

        val vulnerabilities = ortResult.getAdvisorResults()
            .flatMap { entry ->
                entry.value.flatMap { advisorResult ->
                    advisorResult.vulnerabilities.map { vulnerability ->
                        // Find the vulnerability reference with the highest severity.
                        val maxSeverity = vulnerability.references
                            .mapNotNull { it.severity }
                            .maxByOrNull { severity ->
                                VulnerabilityRating.fromString(severity)?.ordinal
                                    ?: VulnerabilityRating.NONE.ordinal
                            } ?: VulnerabilityRating.NONE.name

                        VulnerabilityWithDetails(
                            vulnerability = vulnerability.mapToModel(),
                            identifier = entry.key.mapToModel(),
                            rating = VulnerabilityRating.fromString(maxSeverity)
                                ?: VulnerabilityRating.NONE,
                            advisor = advisorResult.advisor.mapToModel(),
                            purl = ortResult.getPackage(entry.key)?.metadata?.purl ?: entry.key.toPurl()
                        )
                    }
                }
            }

        val resolutions = ortResult.getResolutions().vulnerabilities

        // Need only to support a single sort order. This is hardcoded in the router implementation.
        var comparator = compareBy<VulnerabilityWithDetails> { 0 } // Default comparator that does nothing.

        // If no sort order is given (which is the case in some test cases), then sort by external id,
        // in order to return stable results to the test cases.
        if (parameters.sortFields.isEmpty()) {
            comparator = comparator.thenBy { it.vulnerability.externalId }
        } else {
            parameters.sortFields.forEach { orderField ->
                when (orderField.name) {
                    "externalId" -> {
                        comparator = when (orderField.direction) {
                            OrderDirection.ASCENDING -> comparator.thenBy { it.vulnerability.externalId }
                            OrderDirection.DESCENDING -> comparator.thenByDescending { it.vulnerability.externalId }
                        }
                    }
                    else -> {
                        throw QueryParametersException("Unsupported field for sorting: '${orderField.name}'.")
                    }
                }
            }
        }

        val sortedVulnerabilities = vulnerabilities.sortedWith(comparator)

        val filteredVulnerabilities = sortedVulnerabilities.applyResultFilter(vulnerabilityFilters, resolutions)

        val limitedVulnerabilities = filteredVulnerabilities
            .drop(parameters.offset?.toInt() ?: 0)
            .take(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)

        val vulnerabilityResolutionDefinitions = db.dbQuery {
            RepositoryConfigurationsVulnerabilityResolutionsTable
                .innerJoin(VulnerabilityResolutionsTable)
                .innerJoin(RepositoryConfigurationsTable)
                .innerJoin(VulnerabilityResolutionDefinitionsTable)
                .select(
                    VulnerabilityResolutionsTable.columns + VulnerabilityResolutionDefinitionsTable.columns
                )
                .where { RepositoryConfigurationsTable.ortRunId eq ortRunId }
                .map { row ->
                    row.toVulnerabilityResolutionDefinition() to ModelVulnerabilityResolution(
                        row[VulnerabilityResolutionsTable.externalId],
                        row[VulnerabilityResolutionsTable.reason],
                        row[VulnerabilityResolutionsTable.comment]
                    )
                }
        }

        val newVulnerabilityResolutionDefinitions = db.dbQuery {
            VulnerabilityResolutionDefinitionsTable
                .select(VulnerabilityResolutionDefinitionsTable.columns)
                .where {
                    (VulnerabilityResolutionDefinitionsTable.repositoryId eq ortRun.repositoryId) and
                            (VulnerabilityResolutionDefinitionsTable.contextRunId greaterEq ortRun.id) and
                            (VulnerabilityResolutionDefinitionsTable.archived eq false)
                }
                .map { row -> row.toVulnerabilityResolutionDefinition() }
        }

        val vulnerabilitiesWithResolutions = limitedVulnerabilities.map { vulnerabilityWithDetails ->
            val matchingNewDefinitions = newVulnerabilityResolutionDefinitions.filter { definition ->
                definition.idMatchers.any { idMatcher ->
                    VulnerabilityResolution(
                        idMatcher,
                        VulnerabilityResolutionReason.valueOf(definition.reason.name),
                        definition.comment
                    ).matches(vulnerabilityWithDetails.vulnerability.mapToOrt())
                }
            }
            val matchingResolutions = resolutions.filter {
                it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt())
            }
            vulnerabilityWithDetails.copy(
                resolutions = matchingResolutions.map {
                    val resolution = it.mapToModel()

                    val definition = vulnerabilityResolutionDefinitions
                        .firstOrNull { (_, value) ->
                            resolution == value
                        }?.first

                    AppliedVulnerabilityResolution(
                        resolution,
                        definition
                    )
                },
                newMatchingResolutionDefinitions = matchingNewDefinitions
            )
        }

        return ListQueryResult(
            data = vulnerabilitiesWithResolutions,
            params = parameters,
            totalCount = filteredVulnerabilities.size.toLong()
        )
    }

    private fun List<VulnerabilityWithDetails>.applyResultFilter(
        vulnerabilityFilters: VulnerabilityFilters,
        resolutions: List<VulnerabilityResolution>
    ): List<VulnerabilityWithDetails> = when (vulnerabilityFilters.resolved) {
        true -> {
            filter { vulnerabilityWithDetails ->
                resolutions.any { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        false -> {
            filter { vulnerabilityWithDetails ->
                resolutions.none { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        null -> this
    }

    /**
     * List vulnerabilities found in provided ORT runs
     */
    suspend fun listForOrtRuns(
        ortRunIds: List<Long>,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        filters: VulnerabilityForRunsFilters = VulnerabilityForRunsFilters()
    ): ListQueryResult<VulnerabilityWithAccumulatedData> = db.dbQuery {
        val runIdsAlias = runIdsAlias()
        val repositoriesCountAlias = repositoriesCountAlias()
        val ratingAlias = ratingAlias()

        val curatedPurlSubquery = PackageCurationDataTable
            .innerJoin(PackageCurationsTable)
            .innerJoin(ResolvedPackageCurationsTable)
            .innerJoin(ResolvedPackageCurationProvidersTable)
            .innerJoin(ResolvedConfigurationsTable)
            .select(PackageCurationDataTable.purl)
            .where {
                (ResolvedConfigurationsTable.ortRunId eq OrtRunsTable.id) and (
                    PackageCurationsTable.identifierId eq
                    IdentifiersTable.id
                ) and (PackageCurationDataTable.purl.isNotNull())
            }
            .orderBy(ResolvedPackageCurationProvidersTable.rank)
            .orderBy(ResolvedPackageCurationsTable.rank)
            .limit(1)

        val curatedPurlExpression: Expression<String?> = wrapAsExpression(curatedPurlSubquery)

        val purlAlias = CustomFunction(
            "COALESCE",
            PackagesTable.purl.columnType,
            curatedPurlExpression,
            PackagesTable.purl
        ).alias("purl")

        val vulnerabilityIdAlias = VulnerabilitiesTable.id.alias("vulnerability_id")
        val identifierIdAlias = IdentifiersTable.id.alias("identifier_id")
        val ortRunIdAlias = OrtRunsTable.id.alias("ort_run_id")

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(OrtRunsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(AnalyzerJobsTable)
            .innerJoin(AnalyzerRunsTable)
            .innerJoin(PackagesAnalyzerRunsTable)
            .innerJoin(PackagesTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(vulnerabilityIdAlias, identifierIdAlias, ortRunIdAlias, purlAlias, ratingAlias)
            .where { OrtRunsTable.id inList ortRunIds }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlAlias, OrtRunsTable.id)
            .alias("subquery")

        val purlColumn = subQuery[purlAlias]
        val vulnerabilityIdColumn = subQuery[vulnerabilityIdAlias]
        val identifierIdColumn = subQuery[identifierIdAlias]
        val ortRunIdColumn = subQuery[ortRunIdAlias]
        val ratingColumn = subQuery[ratingAlias]

        val maxRatingAlias = Max(ratingColumn, IntegerColumnType()).alias("maxRating")

        val query = subQuery
            .innerJoin(VulnerabilitiesTable, { vulnerabilityIdColumn }, { VulnerabilitiesTable.id })
            .innerJoin(IdentifiersTable, { identifierIdColumn }, { IdentifiersTable.id })
            .innerJoin(OrtRunsTable, { ortRunIdColumn }, { OrtRunsTable.id })
            .innerJoin(RepositoriesTable)
            .select(
                VulnerabilitiesTable.columns + IdentifiersTable.columns + maxRatingAlias + runIdsAlias +
                        repositoriesCountAlias + purlColumn
            )
            .where {
                var condition: Op<Boolean> = Op.TRUE

                filters.rating?.let {
                    val ratingsAsInt = it.value.map { severity -> severity.ordinal }
                    condition = condition and when (it.operator) {
                        ComparisonOperator.IN -> ratingColumn inList ratingsAsInt
                        else -> ratingColumn notInList ratingsAsInt
                    }
                }

                filters.identifier?.let {
                    val namespaceWithSlash = Case()
                        .When(
                            IdentifiersTable.namespace neq stringLiteral(""),
                            concat(IdentifiersTable.namespace, stringLiteral("/"))
                        )
                        .Else(stringLiteral(":"))

                    val concatenatedIdentifier = concat(
                        IdentifiersTable.type,
                        stringLiteral(":"),
                        namespaceWithSlash,
                        IdentifiersTable.name,
                        stringLiteral("@"),
                        IdentifiersTable.version
                    )

                    condition = condition and concatenatedIdentifier.applyILike(it.value)
                }

                filters.purl?.let {
                    condition = condition and purlColumn.applyILike(it.value)
                }

                filters.externalId?.let {
                    condition = condition and VulnerabilitiesTable.externalId.applyILike(it.value)
                }

                condition
            }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlColumn)

        val orders = mutableListOf<Pair<Expression<*>, SortOrder>>()

        parameters.sortFields.forEach {
            val sortOrder = it.direction.toSortOrder()
            when (it.name) {
                "rating" -> orders += maxRatingAlias to sortOrder
                "repositoriesCount" -> orders += repositoriesCountAlias to sortOrder
                "externalId" -> orders += VulnerabilitiesTable.externalId to sortOrder
                "identifier" -> {
                    orders += IdentifiersTable.type to sortOrder
                    orders += IdentifiersTable.namespace to sortOrder
                    orders += IdentifiersTable.name to sortOrder
                    orders += IdentifiersTable.version to sortOrder
                }
                "purl" -> {
                    orders += purlColumn to sortOrder
                }
                else -> throw QueryParametersException("Unsupported field for sorting: '${it.name}'.")
            }
        }

        val totalCount = query.count()

        val vulnerabilities = query
            .orderBy(*orders.toTypedArray())
            .limit(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)
            .offset(parameters.offset ?: 0)
            .map { row ->
                VulnerabilityWithAccumulatedData(
                    vulnerability = VulnerabilityDao.wrapRow(row).mapToModel(),
                    identifier = IdentifierDao.wrapRow(row).mapToModel(),
                    purl = row[purlColumn],
                    rating = VulnerabilityRating.entries[(row[maxRatingAlias] ?: 0)],
                    ortRunIds = row[runIdsAlias].split(",").map { it.toLong() },
                    repositoriesCount = row[repositoriesCountAlias]
                )
            }

        ListQueryResult(vulnerabilities, parameters, totalCount)
    }

    /** Count vulnerabilities found in provided ORT runs. */
    suspend fun countForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count vulnerabilities by rating in provided ORT runs. */
    suspend fun countByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> = db.dbQuery {
        val countAlias = Count(stringLiteral("*")).alias("count")
        val ratingAlias = ratingAlias()

        val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(VulnerabilitiesTable.id, ratingAlias)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .alias("subQuery")

        val rating = subQuery[ratingAlias]

        subQuery
            .select(rating, countAlias)
            .groupBy(rating)
            .forEach { row ->
                ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
            }

        CountByCategory(ratingToCountMap)
    }
}

/** Alias for determining an advisory overall rating of a vulnerability based on its individual references. */
private fun ratingAlias(): ExpressionWithColumnTypeAlias<Int?> {
    val severityCase = Case()
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "CRITICAL", LiteralOp(IntegerColumnType(), 4))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "HIGH", LiteralOp(IntegerColumnType(), 3))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "MEDIUM", LiteralOp(IntegerColumnType(), 2))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "LOW", LiteralOp(IntegerColumnType(), 1))
        .Else(LiteralOp(IntegerColumnType(), 0))

    return Max(severityCase, IntegerColumnType()).alias("rating")
}

/** Alias for gathering the IDs of the runs where the vulnerability was found in. */
private fun runIdsAlias() = GroupConcat(
    OrtRunsTable.id.castTo(TextColumnType()),
    ",",
    true
).alias("runIds")

/** Alias to return the count for the repositories that the vulnerability was found in. */
private fun repositoriesCountAlias() = Count(
    RepositoriesTable.id,
    true
).alias("repositoriesCount")
