/*
 * Copyright (C) 2024 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services.ortrun

import org.eclipse.apoapsis.ortserver.dao.QueryParametersException
import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorjob.AdvisorJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsIdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityDao
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityReferencesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.ortrun.OrtRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifierDao
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.utils.listCustomQueryCustomOrders
import org.eclipse.apoapsis.ortserver.model.CountByCategory
import org.eclipse.apoapsis.ortserver.model.VulnerabilityFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityRating
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithAccumulatedData
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithDetails
import org.eclipse.apoapsis.ortserver.model.util.ListQueryParameters
import org.eclipse.apoapsis.ortserver.model.util.ListQueryResult
import org.eclipse.apoapsis.ortserver.model.util.OrderDirection
import org.eclipse.apoapsis.ortserver.services.ResourceNotFoundException
import org.eclipse.apoapsis.ortserver.services.utils.toSortOrder

import org.jetbrains.exposed.sql.Case
import org.jetbrains.exposed.sql.Count
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.Expression
import org.jetbrains.exposed.sql.ExpressionWithColumnTypeAlias
import org.jetbrains.exposed.sql.GroupConcat
import org.jetbrains.exposed.sql.IntegerColumnType
import org.jetbrains.exposed.sql.LiteralOp
import org.jetbrains.exposed.sql.Max
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.TextColumnType
import org.jetbrains.exposed.sql.UpperCase
import org.jetbrains.exposed.sql.alias
import org.jetbrains.exposed.sql.castTo
import org.jetbrains.exposed.sql.stringLiteral

import org.ossreviewtoolkit.model.config.VulnerabilityResolution

/**
 * A service to interact with vulnerabilities.
 */
class VulnerabilityService(private val db: Database, private val ortRunService: OrtRunService) {
    fun listForOrtRunId(
        ortRunId: Long,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        vulnerabilityFilters: VulnerabilityFilters = VulnerabilityFilters()
    ): ListQueryResult<VulnerabilityWithDetails> {
        val ortRun = ortRunService.getOrtRun(ortRunId) ?: throw ResourceNotFoundException(
            "ORT run with ID $ortRunId not found."
        )

        val ortResult = ortRunService.generateOrtResult(
            ortRun,
            loadAdvisorRun = true, // Only interested in vulnerabilities (advisor).
            loadScannerRun = false,
            loadEvaluatorRun = false,
            failIfRepoInfoMissing = false
        )

        val vulnerabilities = ortResult.getAdvisorResults()
            .flatMap { entry ->
                entry.value.flatMap { advisorResult ->
                    advisorResult.vulnerabilities.map { vulnerability ->
                        // Find the vulnerability reference with the highest severity.
                        val maxSeverity = vulnerability.references
                            .mapNotNull { it.severity }
                            .maxByOrNull { severity ->
                                VulnerabilityRating.fromString(severity)?.ordinal
                                    ?: VulnerabilityRating.NONE.ordinal
                            } ?: VulnerabilityRating.NONE.name

                        VulnerabilityWithDetails(
                            vulnerability = vulnerability.mapToModel(),
                            identifier = entry.key.mapToModel(),
                            rating = VulnerabilityRating.fromString(maxSeverity)
                                ?: VulnerabilityRating.NONE,
                            advisor = advisorResult.advisor.mapToModel()
                        )
                    }
                }
            }

        val resolutions = ortResult.getResolutions().vulnerabilities

        // Need only to support a single sort order. This is hardcoded in the router implementation.
        var comparator = compareBy<VulnerabilityWithDetails> { 0 } // Default comparator that does nothing.

        // If no sort order is given (which is the case in some test cases), then sort by external id,
        // in order to return stable results to the test cases.
        if (parameters.sortFields.isEmpty()) {
            comparator = comparator.thenBy { it.vulnerability.externalId }
        } else {
            parameters.sortFields.forEach { orderField ->
                when (orderField.name) {
                    "externalId" -> {
                        comparator = when (orderField.direction) {
                            OrderDirection.ASCENDING -> comparator.thenBy { it.vulnerability.externalId }
                            OrderDirection.DESCENDING -> comparator.thenByDescending { it.vulnerability.externalId }
                        }
                    }
                    else -> {
                        throw QueryParametersException("Unsupported field for sorting: '${orderField.name}'.")
                    }
                }
            }
        }

        val sortedVulnerabilities = vulnerabilities.sortedWith(comparator)

        val filteredVulnerabilities = sortedVulnerabilities.applyResultFilter(vulnerabilityFilters, resolutions)

        val limitedVulnerabilities = filteredVulnerabilities
            .drop(parameters.offset?.toInt() ?: 0)
            .take(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)

        val vulnerabilitiesWithResolutions = limitedVulnerabilities.map { vulnerabilityWithDetails ->
            val matchingResolutions = resolutions.filter {
                it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt())
            }
            vulnerabilityWithDetails.copy(resolutions = matchingResolutions.map { it.mapToModel() })
        }

        return ListQueryResult(
            data = vulnerabilitiesWithResolutions,
            params = parameters,
            totalCount = filteredVulnerabilities.size.toLong()
        )
    }

    private fun List<VulnerabilityWithDetails>.applyResultFilter(
        vulnerabilityFilters: VulnerabilityFilters,
        resolutions: List<VulnerabilityResolution>
    ): List<VulnerabilityWithDetails> = when (vulnerabilityFilters.resolved) {
        true -> {
            filter { vulnerabilityWithDetails ->
                resolutions.any { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        false -> {
            filter { vulnerabilityWithDetails ->
                resolutions.none { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        null -> this
    }

    /**
     * List vulnerabilities found in provided ORT runs
     */
    suspend fun listForOrtRuns(
        ortRunIds: List<Long>,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT
    ): ListQueryResult<VulnerabilityWithAccumulatedData> = db.dbQuery {
        val runIdsAlias = runIdsAlias()
        val repositoriesCountAlias = repositoriesCountAlias()
        val ratingAlias = ratingAlias()

        val orders = mutableListOf<Pair<Expression<*>, SortOrder>>()

        parameters.sortFields.forEach {
            val sortOrder = it.direction.toSortOrder()
            when (it.name) {
                "rating" -> orders += ratingAlias to sortOrder
                "repositoriesCount" -> orders += repositoriesCountAlias to sortOrder
                "externalId" -> orders += VulnerabilitiesTable.externalId to sortOrder
                "identifier" -> {
                    orders += IdentifiersTable.type to sortOrder
                    orders += IdentifiersTable.namespace to sortOrder
                    orders += IdentifiersTable.name to sortOrder
                    orders += IdentifiersTable.version to sortOrder
                }
                else -> throw QueryParametersException("Unsupported field for sorting: '${it.name}'.")
            }
        }

        listCustomQueryCustomOrders(parameters, orders, ResultRow::toVulnerabilityWithAccumulatedData) {
            VulnerabilitiesTable
                .innerJoin(AdvisorResultsVulnerabilitiesTable)
                .innerJoin(AdvisorResultsTable)
                .innerJoin(AdvisorRunsIdentifiersTable)
                .innerJoin(AdvisorRunsTable)
                .innerJoin(AdvisorJobsTable)
                .innerJoin(OrtRunsTable)
                .innerJoin(RepositoriesTable)
                .innerJoin(IdentifiersTable)
                .innerJoin(VulnerabilityReferencesTable)
                .select(
                    VulnerabilitiesTable.columns +
                            IdentifiersTable.columns +
                            ratingAlias +
                            runIdsAlias +
                            repositoriesCountAlias
                )
                .where { OrtRunsTable.id inList ortRunIds }
                .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
        }
    }

    /** Count vulnerabilities found in provided ORT runs. */
    suspend fun countForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count vulnerabilities by rating in provided ORT runs. */
    suspend fun countByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> = db.dbQuery {
        val countAlias = Count(stringLiteral("*")).alias("count")
        val ratingAlias = ratingAlias()

        val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(VulnerabilitiesTable.id, ratingAlias)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .alias("subQuery")

        val rating = subQuery[ratingAlias]

        subQuery
            .select(rating, countAlias)
            .groupBy(rating)
            .forEach { row ->
                ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
            }

        CountByCategory(ratingToCountMap)
    }
}

/** Alias for determining an advisory overall rating of a vulnerability based on its individual references. */
private fun ratingAlias(): ExpressionWithColumnTypeAlias<Int?> {
    val severityCase = Case()
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "CRITICAL", LiteralOp(IntegerColumnType(), 4))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "HIGH", LiteralOp(IntegerColumnType(), 3))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "MEDIUM", LiteralOp(IntegerColumnType(), 2))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "LOW", LiteralOp(IntegerColumnType(), 1))
        .Else(LiteralOp(IntegerColumnType(), 0))

    return Max(severityCase, IntegerColumnType()).alias("rating")
}

/** Alias for gathering the IDs of the runs where the vulnerability was found in. */
private fun runIdsAlias() = GroupConcat(
    OrtRunsTable.id.castTo(TextColumnType()),
    ",",
    true
).alias("runIds")

/** Alias to return the count for the repositories that the vulnerability was found in. */
private fun repositoriesCountAlias() = Count(
    RepositoriesTable.id,
    true
).alias("repositoriesCount")

private fun ResultRow.toVulnerabilityWithAccumulatedData() = VulnerabilityWithAccumulatedData(
    vulnerability = VulnerabilityDao.wrapRow(this).mapToModel(),
    identifier = IdentifierDao.wrapRow(this).mapToModel(),
    rating = VulnerabilityRating.entries[(this[ratingAlias()] ?: 0)],
    ortRunIds = this[runIdsAlias()].split(",").map { it.toLong() },
    repositoriesCount = this[repositoriesCountAlias()]
)
