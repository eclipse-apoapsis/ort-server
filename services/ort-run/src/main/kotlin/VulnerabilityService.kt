/*
 * Copyright (C) 2024 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.services.ortrun

import org.eclipse.apoapsis.ortserver.dao.QueryParametersException
import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorjob.AdvisorJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorResultsVulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsIdentifiersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.AdvisorRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilitiesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityDao
import org.eclipse.apoapsis.ortserver.dao.repositories.advisorrun.VulnerabilityReferencesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerjob.AnalyzerJobsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.AnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesAnalyzerRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.analyzerrun.PackagesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.ortrun.OrtRunsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationDataTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.PackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedConfigurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationProvidersTable
import org.eclipse.apoapsis.ortserver.dao.repositories.resolvedconfiguration.ResolvedPackageCurationsTable
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifierDao
import org.eclipse.apoapsis.ortserver.dao.tables.shared.IdentifiersTable
import org.eclipse.apoapsis.ortserver.model.CountByCategory
import org.eclipse.apoapsis.ortserver.model.VulnerabilityFilters
import org.eclipse.apoapsis.ortserver.model.VulnerabilityRating
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithAccumulatedData
import org.eclipse.apoapsis.ortserver.model.VulnerabilityWithDetails
import org.eclipse.apoapsis.ortserver.model.util.ListQueryParameters
import org.eclipse.apoapsis.ortserver.model.util.ListQueryResult
import org.eclipse.apoapsis.ortserver.model.util.OrderDirection
import org.eclipse.apoapsis.ortserver.services.ResourceNotFoundException
import org.eclipse.apoapsis.ortserver.services.utils.toSortOrder

import org.jetbrains.exposed.sql.Case
import org.jetbrains.exposed.sql.Count
import org.jetbrains.exposed.sql.CustomFunction
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.Expression
import org.jetbrains.exposed.sql.ExpressionWithColumnTypeAlias
import org.jetbrains.exposed.sql.GroupConcat
import org.jetbrains.exposed.sql.IntegerColumnType
import org.jetbrains.exposed.sql.LiteralOp
import org.jetbrains.exposed.sql.Max
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.TextColumnType
import org.jetbrains.exposed.sql.UpperCase
import org.jetbrains.exposed.sql.alias
import org.jetbrains.exposed.sql.and
import org.jetbrains.exposed.sql.castTo
import org.jetbrains.exposed.sql.innerJoin
import org.jetbrains.exposed.sql.stringLiteral
import org.jetbrains.exposed.sql.wrapAsExpression

import org.ossreviewtoolkit.model.config.VulnerabilityResolution
import org.ossreviewtoolkit.model.utils.toPurl

/**
 * A service to interact with vulnerabilities.
 */
class VulnerabilityService(private val db: Database, private val ortRunService: OrtRunService) {
    fun listForOrtRunId(
        ortRunId: Long,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT,
        vulnerabilityFilters: VulnerabilityFilters = VulnerabilityFilters()
    ): ListQueryResult<VulnerabilityWithDetails> {
        val ortRun = ortRunService.getOrtRun(ortRunId) ?: throw ResourceNotFoundException(
            "ORT run with ID $ortRunId not found."
        )

        val ortResult = ortRunService.generateOrtResult(
            ortRun,
            loadAdvisorRun = true, // Only interested in vulnerabilities (advisor).
            loadScannerRun = false,
            loadEvaluatorRun = false,
            failIfRepoInfoMissing = false
        )

        val vulnerabilities = ortResult.getAdvisorResults()
            .flatMap { entry ->
                entry.value.flatMap { advisorResult ->
                    advisorResult.vulnerabilities.map { vulnerability ->
                        // Find the vulnerability reference with the highest severity.
                        val maxSeverity = vulnerability.references
                            .mapNotNull { it.severity }
                            .maxByOrNull { severity ->
                                VulnerabilityRating.fromString(severity)?.ordinal
                                    ?: VulnerabilityRating.NONE.ordinal
                            } ?: VulnerabilityRating.NONE.name

                        VulnerabilityWithDetails(
                            vulnerability = vulnerability.mapToModel(),
                            identifier = entry.key.mapToModel(),
                            rating = VulnerabilityRating.fromString(maxSeverity)
                                ?: VulnerabilityRating.NONE,
                            advisor = advisorResult.advisor.mapToModel(),
                            purl = ortResult.getPackage(entry.key)?.metadata?.purl ?: entry.key.toPurl()
                        )
                    }
                }
            }

        val resolutions = ortResult.getResolutions().vulnerabilities

        // Need only to support a single sort order. This is hardcoded in the router implementation.
        var comparator = compareBy<VulnerabilityWithDetails> { 0 } // Default comparator that does nothing.

        // If no sort order is given (which is the case in some test cases), then sort by external id,
        // in order to return stable results to the test cases.
        if (parameters.sortFields.isEmpty()) {
            comparator = comparator.thenBy { it.vulnerability.externalId }
        } else {
            parameters.sortFields.forEach { orderField ->
                when (orderField.name) {
                    "externalId" -> {
                        comparator = when (orderField.direction) {
                            OrderDirection.ASCENDING -> comparator.thenBy { it.vulnerability.externalId }
                            OrderDirection.DESCENDING -> comparator.thenByDescending { it.vulnerability.externalId }
                        }
                    }
                    else -> {
                        throw QueryParametersException("Unsupported field for sorting: '${orderField.name}'.")
                    }
                }
            }
        }

        val sortedVulnerabilities = vulnerabilities.sortedWith(comparator)

        val filteredVulnerabilities = sortedVulnerabilities.applyResultFilter(vulnerabilityFilters, resolutions)

        val limitedVulnerabilities = filteredVulnerabilities
            .drop(parameters.offset?.toInt() ?: 0)
            .take(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)

        val vulnerabilitiesWithResolutions = limitedVulnerabilities.map { vulnerabilityWithDetails ->
            val matchingResolutions = resolutions.filter {
                it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt())
            }
            vulnerabilityWithDetails.copy(resolutions = matchingResolutions.map { it.mapToModel() })
        }

        return ListQueryResult(
            data = vulnerabilitiesWithResolutions,
            params = parameters,
            totalCount = filteredVulnerabilities.size.toLong()
        )
    }

    private fun List<VulnerabilityWithDetails>.applyResultFilter(
        vulnerabilityFilters: VulnerabilityFilters,
        resolutions: List<VulnerabilityResolution>
    ): List<VulnerabilityWithDetails> = when (vulnerabilityFilters.resolved) {
        true -> {
            filter { vulnerabilityWithDetails ->
                resolutions.any { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        false -> {
            filter { vulnerabilityWithDetails ->
                resolutions.none { it.matches(vulnerabilityWithDetails.vulnerability.mapToOrt()) }
            }
        }

        null -> this
    }

    /**
     * List vulnerabilities found in provided ORT runs
     */
    suspend fun listForOrtRuns(
        ortRunIds: List<Long>,
        parameters: ListQueryParameters = ListQueryParameters.DEFAULT
    ): ListQueryResult<VulnerabilityWithAccumulatedData> = db.dbQuery {
        val runIdsAlias = runIdsAlias()
        val repositoriesCountAlias = repositoriesCountAlias()
        val ratingAlias = ratingAlias()

        val curatedPurlSubquery = PackageCurationDataTable
            .innerJoin(PackageCurationsTable)
            .innerJoin(ResolvedPackageCurationsTable)
            .innerJoin(ResolvedPackageCurationProvidersTable)
            .innerJoin(ResolvedConfigurationsTable)
            .select(PackageCurationDataTable.purl)
            .where {
                (ResolvedConfigurationsTable.ortRunId eq OrtRunsTable.id) and (
                    PackageCurationsTable.identifierId eq
                    IdentifiersTable.id
                ) and (PackageCurationDataTable.purl.isNotNull())
            }
            .orderBy(ResolvedPackageCurationProvidersTable.rank)
            .orderBy(ResolvedPackageCurationsTable.rank)
            .limit(1)

        val curatedPurlExpression: Expression<String?> = wrapAsExpression(curatedPurlSubquery)

        val purlAlias = CustomFunction(
            "COALESCE",
            PackagesTable.purl.columnType,
            curatedPurlExpression,
            PackagesTable.purl
        ).alias("purl")

        val vulnerabilityIdAlias = VulnerabilitiesTable.id.alias("vulnerability_id")
        val identifierIdAlias = IdentifiersTable.id.alias("identifier_id")
        val ortRunIdAlias = OrtRunsTable.id.alias("ort_run_id")

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(OrtRunsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(AnalyzerJobsTable)
            .innerJoin(AnalyzerRunsTable)
            .innerJoin(PackagesAnalyzerRunsTable)
            .innerJoin(PackagesTable)
            .select(vulnerabilityIdAlias, identifierIdAlias, ortRunIdAlias, purlAlias)
            .where { OrtRunsTable.id inList ortRunIds }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlAlias, OrtRunsTable.id)
            .alias("subquery")

        val purlColumn = subQuery[purlAlias]
        val vulnerabilityIdColumn = subQuery[vulnerabilityIdAlias]
        val identifierIdColumn = subQuery[identifierIdAlias]
        val ortRunIdColumn = subQuery[ortRunIdAlias]

        val query = subQuery
            .innerJoin(VulnerabilitiesTable, { vulnerabilityIdColumn }, { VulnerabilitiesTable.id })
            .innerJoin(VulnerabilityReferencesTable)
            .innerJoin(IdentifiersTable, { identifierIdColumn }, { IdentifiersTable.id })
            .innerJoin(OrtRunsTable, { ortRunIdColumn }, { OrtRunsTable.id })
            .innerJoin(RepositoriesTable)
            .select(
                VulnerabilitiesTable.columns + IdentifiersTable.columns + ratingAlias + runIdsAlias +
                        repositoriesCountAlias + purlColumn
            )
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id, purlColumn)

        val orders = mutableListOf<Pair<Expression<*>, SortOrder>>()

        parameters.sortFields.forEach {
            val sortOrder = it.direction.toSortOrder()
            when (it.name) {
                "rating" -> orders += ratingAlias to sortOrder
                "repositoriesCount" -> orders += repositoriesCountAlias to sortOrder
                "externalId" -> orders += VulnerabilitiesTable.externalId to sortOrder
                "identifier" -> {
                    orders += IdentifiersTable.type to sortOrder
                    orders += IdentifiersTable.namespace to sortOrder
                    orders += IdentifiersTable.name to sortOrder
                    orders += IdentifiersTable.version to sortOrder
                }
                "purl" -> {
                    orders += purlColumn to sortOrder
                }
                else -> throw QueryParametersException("Unsupported field for sorting: '${it.name}'.")
            }
        }

        val totalCount = query.count()

        val vulnerabilities = query
            .orderBy(*orders.toTypedArray())
            .limit(parameters.limit ?: ListQueryParameters.DEFAULT_LIMIT)
            .map { row ->
                VulnerabilityWithAccumulatedData(
                    vulnerability = VulnerabilityDao.wrapRow(row).mapToModel(),
                    identifier = IdentifierDao.wrapRow(row).mapToModel(),
                    purl = row[purlColumn],
                    rating = VulnerabilityRating.entries[(row[ratingAlias] ?: 0)],
                    ortRunIds = row[runIdsAlias].split(",").map { it.toLong() },
                    repositoriesCount = row[repositoriesCountAlias]
                )
            }

        ListQueryResult(vulnerabilities, parameters, totalCount)
    }

    /** Count vulnerabilities found in provided ORT runs. */
    suspend fun countForOrtRunIds(vararg ortRunIds: Long): Long = db.dbQuery {
        VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .select(VulnerabilitiesTable.id)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .count()
    }

    /** Count vulnerabilities by rating in provided ORT runs. */
    suspend fun countByRatingForOrtRunIds(vararg ortRunIds: Long): CountByCategory<VulnerabilityRating> = db.dbQuery {
        val countAlias = Count(stringLiteral("*")).alias("count")
        val ratingAlias = ratingAlias()

        val ratingToCountMap = VulnerabilityRating.entries.associateWithTo(mutableMapOf()) { 0L }

        val subQuery = VulnerabilitiesTable
            .innerJoin(AdvisorResultsVulnerabilitiesTable)
            .innerJoin(AdvisorResultsTable)
            .innerJoin(AdvisorRunsIdentifiersTable)
            .innerJoin(AdvisorRunsTable)
            .innerJoin(AdvisorJobsTable)
            .innerJoin(IdentifiersTable)
            .innerJoin(VulnerabilityReferencesTable)
            .select(VulnerabilitiesTable.id, ratingAlias)
            .where { AdvisorJobsTable.ortRunId inList ortRunIds.asList() }
            .groupBy(VulnerabilitiesTable.id, IdentifiersTable.id)
            .alias("subQuery")

        val rating = subQuery[ratingAlias]

        subQuery
            .select(rating, countAlias)
            .groupBy(rating)
            .forEach { row ->
                ratingToCountMap[VulnerabilityRating.entries[row.getOrNull(rating) ?: 0]] = row[countAlias]
            }

        CountByCategory(ratingToCountMap)
    }
}

/** Alias for determining an advisory overall rating of a vulnerability based on its individual references. */
private fun ratingAlias(): ExpressionWithColumnTypeAlias<Int?> {
    val severityCase = Case()
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "CRITICAL", LiteralOp(IntegerColumnType(), 4))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "HIGH", LiteralOp(IntegerColumnType(), 3))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "MEDIUM", LiteralOp(IntegerColumnType(), 2))
        .When(UpperCase(VulnerabilityReferencesTable.severity) eq "LOW", LiteralOp(IntegerColumnType(), 1))
        .Else(LiteralOp(IntegerColumnType(), 0))

    return Max(severityCase, IntegerColumnType()).alias("rating")
}

/** Alias for gathering the IDs of the runs where the vulnerability was found in. */
private fun runIdsAlias() = GroupConcat(
    OrtRunsTable.id.castTo(TextColumnType()),
    ",",
    true
).alias("runIds")

/** Alias to return the count for the repositories that the vulnerability was found in. */
private fun repositoriesCountAlias() = Count(
    RepositoriesTable.id,
    true
).alias("repositoriesCount")
