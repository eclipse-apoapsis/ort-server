/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.dao.tables

import org.eclipse.apoapsis.ortserver.dao.repositories.repository.RepositoriesTable
import org.eclipse.apoapsis.ortserver.dao.utils.jsonb
import org.eclipse.apoapsis.ortserver.model.ChangeEventEntityType
import org.eclipse.apoapsis.ortserver.model.RepositoryId
import org.eclipse.apoapsis.ortserver.model.VulnerabilityResolutionDefinition
import org.eclipse.apoapsis.ortserver.model.VulnerabilityResolutionReason
import org.eclipse.apoapsis.ortserver.model.util.OptionalValue

import org.jetbrains.exposed.dao.id.LongIdTable
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.insertAndGetId
import org.jetbrains.exposed.sql.update

/**
 * A table to store definitions of vulnerability resolutions.
 */
object VulnerabilityResolutionDefinitionsTable : LongIdTable("vulnerability_resolution_definitions") {
    val repositoryId = reference("repository_id", RepositoriesTable)

    val contextRunId = long("context_run_id")
    val idMatchers = jsonb<List<String>>("id_matchers")
    val reason = text("reason")
    val comment = text("comment")
    val archived = bool("archived").default(false)

    fun insert(
        hierarchyId: RepositoryId,
        runIdInput: Long,
        idMatchersInput: List<String>,
        reasonInput: VulnerabilityResolutionReason,
        commentInput: String
    ): Long {
        return insertAndGetId {
            it[repositoryId] = hierarchyId.value
            it[contextRunId] = runIdInput
            it[idMatchers] = idMatchersInput
            it[reason] = reasonInput.name
            it[comment] = commentInput
        }.value
    }

    fun get(definitionId: Long): VulnerabilityResolutionDefinition {
        return select(columns)
            .where { id eq definitionId }
            .single()
            .toVulnerabilityResolutionDefinition()
    }

    fun getOrNull(definitionId: Long): VulnerabilityResolutionDefinition? {
        val row = select(columns)
            .where { id eq definitionId }
            .singleOrNull() ?: return null

        return row.toVulnerabilityResolutionDefinition()
    }

    fun updateDefinition(
        definitionId: Long,
        idMatchersInput: OptionalValue<List<String>> = OptionalValue.Absent,
        reasonInput: OptionalValue<VulnerabilityResolutionReason> = OptionalValue.Absent,
        commentInput: OptionalValue<String> = OptionalValue.Absent,
        archivedInput: OptionalValue<Boolean> = OptionalValue.Absent
    ) {
        update({ id eq definitionId }) { stmt ->
            idMatchersInput.ifPresent { stmt[idMatchers] = it }
            reasonInput.ifPresent { stmt[reason] = it.name }
            commentInput.ifPresent { stmt[comment] = it }
            archivedInput.ifPresent { stmt[archived] = it }
        }
    }

    fun ResultRow.toVulnerabilityResolutionDefinition() = VulnerabilityResolutionDefinition(
        this[id].value,
        RepositoryId(this[repositoryId].value),
        this[contextRunId],
        this[idMatchers],
        VulnerabilityResolutionReason.valueOf(this[reason]),
        this[comment],
        this[archived],
        ChangeLogTable.getAllByEntityTypeAndId(
            ChangeEventEntityType.VULNERABILITY_RESOLUTION_DEFINITION,
            this[id].value.toString()
        )
    )
}
