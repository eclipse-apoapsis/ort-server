/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package ort.eclipse.apoapsis.ortserver.components.search.routes

import io.kotest.assertions.ktor.client.shouldHaveStatus
import io.kotest.matchers.collections.shouldBeEmpty
import io.kotest.matchers.collections.shouldBeSingleton
import io.kotest.matchers.collections.shouldContainExactly
import io.kotest.matchers.collections.shouldContainExactlyInAnyOrder
import io.kotest.matchers.nulls.shouldBeNull
import io.kotest.matchers.shouldBe

import io.ktor.client.call.body
import io.ktor.client.request.get
import io.ktor.client.request.parameter
import io.ktor.http.HttpStatusCode

import io.mockk.coEvery

import org.eclipse.apoapsis.ortserver.components.search.apimodel.RunWithVulnerability
import org.eclipse.apoapsis.ortserver.model.CompoundHierarchyId
import org.eclipse.apoapsis.ortserver.model.HierarchyLevel
import org.eclipse.apoapsis.ortserver.model.OrganizationId
import org.eclipse.apoapsis.ortserver.model.ProductId
import org.eclipse.apoapsis.ortserver.model.RepositoryId
import org.eclipse.apoapsis.ortserver.model.runs.Identifier
import org.eclipse.apoapsis.ortserver.model.util.HierarchyFilter

import ort.eclipse.apoapsis.ortserver.components.search.SearchIntegrationTest
import ort.eclipse.apoapsis.ortserver.components.search.createRunWithVulnerability
import ort.eclipse.apoapsis.ortserver.components.search.createRunWithVulnerabilityAndCuratedPurl
import ort.eclipse.apoapsis.ortserver.components.search.createRunWithVulnerabilityForPurlSearch
import ort.eclipse.apoapsis.ortserver.components.search.toApiIdentifier
import ort.eclipse.apoapsis.ortserver.components.search.toPurl

private const val SEARCH_ROUTE = "/search/vulnerability"

class GetRunsWithVulnerabilityIntegrationTest : SearchIntegrationTest({
    "GetRunsWithVulnerability" should {
        "return BadRequest if externalId is missing" {
            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE)

                response shouldHaveStatus HttpStatusCode.BadRequest
            }
        }

        "return BadRequest if multiple scope parameters are provided" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("scope-test")
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = "CVE-2021-scope-test"
            )

            searchTestApplication { client ->
                val withTwoScopes = client.get(SEARCH_ROUTE) {
                    parameter("externalId", run.externalId)
                    parameter("organizationId", run.organizationId.toString())
                    parameter("productId", run.productId.toString())
                }

                withTwoScopes shouldHaveStatus HttpStatusCode.BadRequest

                val withAllScopes = client.get(SEARCH_ROUTE) {
                    parameter("externalId", run.externalId)
                    parameter("organizationId", run.organizationId.toString())
                    parameter("productId", run.productId.toString())
                    parameter("repositoryId", run.repositoryId.toString())
                }

                withAllScopes shouldHaveStatus HttpStatusCode.BadRequest
            }
        }

        "return runs globally when vulnerability exists" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("global")
            val vulnId = "CVE-2021-global"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }

        "return runs scoped to organization" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("organization")
            val vulnId = "CVE-2021-organization"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val otherOrg = fixtures.createOrganization(name = "vuln-int-other-org")
            val otherProd = fixtures.createProduct(name = "vuln-int-other-prod", organizationId = otherOrg.id)
            val otherRepo = fixtures.createRepository(
                productId = otherProd.id,
                url = "https://example.com/vuln-int-org-scope.git"
            )
            createRunWithVulnerability(
                fixtures = fixtures,
                repoId = otherRepo.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            coEvery {
                hierarchyAuthorizationService.filterHierarchyIds(
                    any(), any(), any(), any(), OrganizationId(run.organizationId)
                )
            } returns HierarchyFilter(
                transitiveIncludes = mapOf(
                    HierarchyLevel.ORGANIZATION to listOf(
                        CompoundHierarchyId.forOrganization(OrganizationId(run.organizationId))
                    )
                ),
                nonTransitiveIncludes = emptyMap()
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("organizationId", run.organizationId.toString())
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }

        "return runs scoped to product" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("product")
            val vulnId = "CVE-2021-product"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val otherProd = fixtures.createProduct(name = "vuln-int-other-prod-2", organizationId = run.organizationId)
            val otherRepo = fixtures.createRepository(
                productId = otherProd.id,
                url = "https://example.com/vuln-int-product-scope.git"
            )
            createRunWithVulnerability(
                fixtures = fixtures,
                repoId = otherRepo.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            coEvery {
                hierarchyAuthorizationService.filterHierarchyIds(
                    any(), any(), any(), any(), ProductId(run.productId)
                )
            } returns HierarchyFilter(
                transitiveIncludes = mapOf(
                    HierarchyLevel.PRODUCT to listOf(
                        CompoundHierarchyId.forProduct(
                            OrganizationId(run.organizationId),
                            ProductId(run.productId)
                        )
                    )
                ),
                nonTransitiveIncludes = emptyMap()
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("productId", run.productId.toString())
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }

        "return runs scoped to repository" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("repository")
            val vulnId = "CVE-2021-repository"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val otherRepo = fixtures.createRepository(
                productId = run.productId,
                url = "https://example.com/vuln-int-repository-scope.git"
            )
            createRunWithVulnerability(
                fixtures = fixtures,
                repoId = otherRepo.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            coEvery {
                hierarchyAuthorizationService.filterHierarchyIds(
                    any(), any(), any(), any(), RepositoryId(run.repositoryId)
                )
            } returns HierarchyFilter(
                transitiveIncludes = mapOf(
                    HierarchyLevel.REPOSITORY to listOf(
                        CompoundHierarchyId.forRepository(
                            OrganizationId(run.organizationId),
                            ProductId(run.productId),
                            RepositoryId(run.repositoryId)
                        )
                    )
                ),
                nonTransitiveIncludes = emptyMap()
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("repositoryId", run.repositoryId.toString())
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }

        "respect hierarchy filters when fetching runs" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("hierarchy")
            val vulnId = "CVE-2021-hierarchy"
            val allowed = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val otherRepo = fixtures.createRepository(
                productId = allowed.productId,
                url = "https://example.com/vuln-int-filtered.git"
            )
            createRunWithVulnerability(
                fixtures = fixtures,
                repoId = otherRepo.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            coEvery {
                hierarchyAuthorizationService.filterHierarchyIds(any(), any(), any(), any(), any())
            } returns HierarchyFilter(
                transitiveIncludes = mapOf(
                    HierarchyLevel.REPOSITORY to listOf(
                        CompoundHierarchyId.forRepository(
                            OrganizationId(allowed.organizationId),
                            ProductId(allowed.productId),
                            RepositoryId(allowed.repositoryId)
                        )
                    )
                ),
                nonTransitiveIncludes = emptyMap()
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(allowed)
            }
        }

        "return all runs for a vulnerability across scopes" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("aggregate")
            val vulnId = "CVE-2021-aggregate"
            val baseRepoId = fixtures.repository.id
            val run1 = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = baseRepoId,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val run2 = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = baseRepoId,
                pkgId = vulnerabilityIdentifierFor("aggregate-2"),
                vulnerabilityExternalId = vulnId
            )

            val otherOrg = fixtures.createOrganization(name = "vuln-int-agg-org")
            val otherProd = fixtures.createProduct(name = "vuln-int-agg-prod", organizationId = otherOrg.id)
            val otherRepo = fixtures.createRepository(
                productId = otherProd.id,
                url = "https://example.com/vuln-int-aggregate-scope.git"
            )
            val run3 = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = otherRepo.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactlyInAnyOrder(listOf(run1, run2, run3))
            }
        }

        "return empty list when vulnerability not present in scope" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("empty-run")
            val vulnId = "CVE-2021-empty"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )
            val missingVulnId = "CVE-2021-missing"

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", missingVulnId)
                    parameter("repositoryId", run.repositoryId.toString())
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body.shouldBeEmpty()
            }
        }

        "return packageId as non-null and purl as null when returnPurl is false" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("purl-false")
            val vulnId = "CVE-2021-purl-false"
            createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("returnPurl", "false")
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body.shouldBeSingleton {
                    it.purl.shouldBeNull()
                    it.packageId shouldBe pkgId.toApiIdentifier()
                    it.externalId shouldBe vulnId
                }
            }
        }

        "return purl as non-null and packageId as null when returnPurl is true" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("purl-true")
            val vulnId = "CVE-2021-purl-true"
            createRunWithVulnerabilityForPurlSearch(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("returnPurl", "true")
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body.shouldBeSingleton {
                    it.packageId.shouldBeNull()
                    it.purl shouldBe pkgId.toPurl()
                    it.externalId shouldBe vulnId
                }
            }
        }

        "return curated purl when returnPurl is true and curation exists" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("purl-curated")
            val vulnId = "CVE-2021-purl-curated"
            val curatedPurl = "pkg:maven/corrected-ns/corrected-name@1.0.0"
            val run = createRunWithVulnerabilityAndCuratedPurl(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId,
                curatedPurl = curatedPurl
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", vulnId)
                    parameter("returnPurl", "true")
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }

        "support case-insensitive externalId search" {
            val fixtures = dbExtension.fixtures
            val pkgId = vulnerabilityIdentifierFor("case-insensitive")
            val vulnId = "CVE-2021-UPPERCASE"
            val run = createRunWithVulnerability(
                fixtures = fixtures,
                repoId = fixtures.repository.id,
                pkgId = pkgId,
                vulnerabilityExternalId = vulnId
            )

            searchTestApplication { client ->
                val response = client.get(SEARCH_ROUTE) {
                    parameter("externalId", "cve-2021-uppercase")
                }

                response shouldHaveStatus HttpStatusCode.OK

                val body = response.body<List<RunWithVulnerability>>()
                body shouldContainExactly listOf(run)
            }
        }
    }
})

private fun vulnerabilityIdentifierFor(suffix: String) = Identifier(
    type = "maven",
    namespace = "vuln-ns-$suffix",
    name = "vuln-name-$suffix",
    version = "1.0.0"
)
