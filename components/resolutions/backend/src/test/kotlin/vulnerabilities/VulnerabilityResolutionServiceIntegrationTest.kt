/*
 * Copyright (C) 2026 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.components.resolutions.vulnerabilities

import io.kotest.core.spec.style.WordSpec
import io.kotest.matchers.collections.beEmpty
import io.kotest.matchers.collections.containExactly
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.beOfType

import io.mockk.mockk

import org.eclipse.apoapsis.ortserver.components.resolutions.beOk
import org.eclipse.apoapsis.ortserver.components.resolutions.shouldBeErr
import org.eclipse.apoapsis.ortserver.components.resolutions.shouldBeOk
import org.eclipse.apoapsis.ortserver.dao.test.DatabaseTestExtension
import org.eclipse.apoapsis.ortserver.model.RepositoryId
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolution
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolutionReason
import org.eclipse.apoapsis.ortserver.services.RepositoryService
import org.eclipse.apoapsis.ortserver.utils.test.Integration

class VulnerabilityResolutionServiceIntegrationTest : WordSpec({
    tags(Integration)

    val dbExtension = extension(DatabaseTestExtension())

    lateinit var service: VulnerabilityResolutionService
    var repositoryId = RepositoryId(-1)

    beforeEach {
        service = VulnerabilityResolutionService(
            db = dbExtension.db,
            eventStore = VulnerabilityResolutionEventStore(dbExtension.db),
            repositoryService = RepositoryService(
                db = dbExtension.db,
                ortRunRepository = dbExtension.fixtures.ortRunRepository,
                repositoryRepository = dbExtension.fixtures.repositoryRepository,
                analyzerJobRepository = dbExtension.fixtures.analyzerJobRepository,
                advisorJobRepository = dbExtension.fixtures.advisorJobRepository,
                scannerJobRepository = dbExtension.fixtures.scannerJobRepository,
                evaluatorJobRepository = dbExtension.fixtures.evaluatorJobRepository,
                reporterJobRepository = dbExtension.fixtures.reporterJobRepository,
                notifierJobRepository = dbExtension.fixtures.notifierJobRepository,
                authorizationService = mockk()
            )
        )

        repositoryId = RepositoryId(dbExtension.fixtures.repository.id)
    }

    "createResolution()" should {
        "create a resolution for a repository" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.getResolutionsForRepository(repositoryId).shouldBeOk {
                it should containExactly(
                    VulnerabilityResolution(
                        externalId = "CVE-2026-1234",
                        reason = VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                        comment = "This is not a real vulnerability."
                    )
                )
            }
        }

        "fail if the repository does not exist" {
            service.createResolution(
                RepositoryId(-999),
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ).shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.RepositoryNotFound>()
            }

            service.getResolutionsForRepository(repositoryId).shouldBeOk {
                it should beEmpty()
            }
        }

        "fail if there is already a resolution for the given external ID" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ).shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.InvalidState>()
            }
        }
    }

    "deleteResolution()" should {
        "delete an existing resolution" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.deleteResolution(repositoryId, "CVE-2026-1234", "user") should beOk()

            service.getResolutionsForRepository(repositoryId).shouldBeOk {
                it should beEmpty()
            }
        }

        "fail if the repository does not exist" {
            service.deleteResolution(RepositoryId(-999), "CVE-2026-1234", "user").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.RepositoryNotFound>()
            }
        }

        "fail if the resolution does not exist" {
            service.deleteResolution(repositoryId, "CVE-2026-1234", "user").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.ResolutionNotFound>()
            }
        }

        "fail if the resolution is already deleted" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.deleteResolution(repositoryId, "CVE-2026-1234", "user") should beOk()

            service.deleteResolution(repositoryId, "CVE-2026-1234", "user").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.ResolutionNotFound>()
            }
        }
    }

    "getResolution()" should {
        "return an existing resolution" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.getResolution(repositoryId, "CVE-2026-1234").shouldBeOk {
                it shouldBe VulnerabilityResolution(
                    externalId = "CVE-2026-1234",
                    reason = VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                    comment = "This is not a real vulnerability."
                )
            }
        }

        "fail if the repository does not exist" {
            service.getResolution(RepositoryId(-999), "CVE-2026-1234").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.RepositoryNotFound>()
            }
        }

        "fail if the resolution does not exist" {
            service.getResolution(repositoryId, "CVE-2026-1234").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.ResolutionNotFound>()
            }
        }

        "fail if the resolution is deleted" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.deleteResolution(repositoryId, "CVE-2026-1234", "user") should beOk()

            service.getResolution(repositoryId, "CVE-2026-1234").shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.ResolutionNotFound>()
            }
        }
    }

    "getResolutionsForRepository()" should {
        "return all resolutions for a repository" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.createResolution(
                repositoryId,
                "CVE-2026-5678",
                "user",
                VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                "This vulnerability is not actually exploitable."
            ) should beOk()

            service.getResolutionsForRepository(repositoryId).shouldBeOk {
                it should containExactly(
                    VulnerabilityResolution(
                        externalId = "CVE-2026-1234",
                        reason = VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                        comment = "This is not a real vulnerability."
                    ),
                    VulnerabilityResolution(
                        externalId = "CVE-2026-5678",
                        reason = VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                        comment = "This vulnerability is not actually exploitable."
                    )
                )
            }
        }

        "fail if the repository does not exist" {
            service.getResolutionsForRepository(RepositoryId(-999)).shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.RepositoryNotFound>()
            }
        }
    }

    "updateResolution()" should {
        "update an existing resolution" {
            service.createResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.NOT_A_VULNERABILITY,
                "This is not a real vulnerability."
            ) should beOk()

            service.updateResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                "This vulnerability is not actually exploitable."
            ) should beOk()

            service.getResolutionsForRepository(repositoryId).shouldBeOk {
                it should containExactly(
                    VulnerabilityResolution(
                        externalId = "CVE-2026-1234",
                        reason = VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                        comment = "This vulnerability is not actually exploitable."
                    )
                )
            }
        }

        "fail if the repository does not exist" {
            service.updateResolution(
                RepositoryId(-999),
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                "This vulnerability is not actually exploitable."
            ).shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.RepositoryNotFound>()
            }
        }

        "fail if the resolution does not exist" {
            service.updateResolution(
                repositoryId,
                "CVE-2026-1234",
                "user",
                VulnerabilityResolutionReason.INEFFECTIVE_VULNERABILITY,
                "This vulnerability is not actually exploitable."
            ).shouldBeErr {
                it should beOfType<VulnerabilityResolutionError.ResolutionNotFound>()
            }
        }
    }
})
