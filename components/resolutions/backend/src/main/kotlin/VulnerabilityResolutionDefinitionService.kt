/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.components.resolutions

import org.eclipse.apoapsis.ortserver.dao.dbQuery
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.RepositoryConfigurationsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.repositoryconfiguration.RepositoryConfigurationsVulnerabilityResolutionsTable
import org.eclipse.apoapsis.ortserver.dao.repositories.userDisplayName.UserDisplayNameDao
import org.eclipse.apoapsis.ortserver.dao.tables.ChangeLogTable
import org.eclipse.apoapsis.ortserver.dao.tables.VulnerabilityResolutionDefinitionsTable
import org.eclipse.apoapsis.ortserver.model.ChangeEventAction
import org.eclipse.apoapsis.ortserver.model.ChangeEventEntityType
import org.eclipse.apoapsis.ortserver.model.RepositoryId
import org.eclipse.apoapsis.ortserver.model.UserDisplayName
import org.eclipse.apoapsis.ortserver.model.VulnerabilityResolutionDefinition
import org.eclipse.apoapsis.ortserver.model.VulnerabilityResolutionReason
import org.eclipse.apoapsis.ortserver.model.util.OptionalValue
import org.eclipse.apoapsis.ortserver.model.util.asPresent
import org.eclipse.apoapsis.ortserver.services.ortrun.OrtRunService

import org.jetbrains.exposed.sql.Database

/**
 * Service class for managing vulnerability resolution definitions.
 */
class VulnerabilityResolutionDefinitionService(private val db: Database, private val ortRunService: OrtRunService) {
    suspend fun create(
        hierarchyId: RepositoryId,
        contextRunId: Long,
        userDisplayName: UserDisplayName,
        idMatchers: List<String>,
        reason: VulnerabilityResolutionReason,
        comment: String
    ): VulnerabilityResolutionDefinition = db.dbQuery {
        val id = VulnerabilityResolutionDefinitionsTable.insert(
            hierarchyId,
            contextRunId,
            idMatchers,
            reason,
            comment
        )

        addChangeLogEvent(id, ChangeEventAction.CREATE, userDisplayName)

        ortRunService.markAsOutdated(listOf(contextRunId), "New vulnerability resolution added.")

        VulnerabilityResolutionDefinitionsTable.get(id)
    }

    suspend fun archive(id: Long, userDisplayName: UserDisplayName): VulnerabilityResolutionDefinition = db.dbQuery {
        VulnerabilityResolutionDefinitionsTable.updateDefinition(
            id,
            archivedInput = true.asPresent()
        )

        addChangeLogEvent(id, ChangeEventAction.ARCHIVE, userDisplayName)

        val definition = VulnerabilityResolutionDefinitionsTable.get(id)

        ortRunService.markAsOutdated(
            getAffectedRuns(id) + definition.contextRunId,
            "Vulnerability resolution definition archived."
        )

        definition
    }

    suspend fun restore(id: Long, userDisplayName: UserDisplayName): VulnerabilityResolutionDefinition = db.dbQuery {
        VulnerabilityResolutionDefinitionsTable.updateDefinition(
            id,
            archivedInput = false.asPresent()
        )

        addChangeLogEvent(id, ChangeEventAction.RESTORE, userDisplayName)

        val definition = VulnerabilityResolutionDefinitionsTable.get(id)

        ortRunService.markAsOutdated(
            getAffectedRuns(id) + definition.contextRunId,
            "Vulnerability resolution definition restored."
        )

        definition
    }

    suspend fun update(
        id: Long,
        userDisplayName: UserDisplayName,
        idMatchers: OptionalValue<List<String>> = OptionalValue.Absent,
        reason: OptionalValue<VulnerabilityResolutionReason> = OptionalValue.Absent,
        comment: OptionalValue<String> = OptionalValue.Absent
    ): VulnerabilityResolutionDefinition = db.dbQuery {
        VulnerabilityResolutionDefinitionsTable.updateDefinition(
            id,
            idMatchers,
            reason,
            comment
        )

        addChangeLogEvent(id, ChangeEventAction.UPDATE, userDisplayName)

        val definition = VulnerabilityResolutionDefinitionsTable.get(id)

        ortRunService.markAsOutdated(
            getAffectedRuns(id) + definition.contextRunId,
            "Vulnerability resolution definition updated."
        )

        definition
    }

    suspend fun getById(id: Long): VulnerabilityResolutionDefinition? = db.dbQuery {
        VulnerabilityResolutionDefinitionsTable
            .getOrNull(id)
    }

    private fun addChangeLogEvent(
        entityId: Long,
        action: ChangeEventAction,
        userDisplayName: UserDisplayName
    ) {
        val user =
            UserDisplayNameDao.insertOrUpdate(userDisplayName) ?: throw NullPointerException("No user created or found")

        ChangeLogTable.insert(
            ChangeEventEntityType.VULNERABILITY_RESOLUTION_DEFINITION,
            entityId.toString(),
            user.id.value,
            action
        )
    }

    private fun getAffectedRuns(
        definitionId: Long
    ): List<Long> {
        return RepositoryConfigurationsVulnerabilityResolutionsTable
            .innerJoin(RepositoryConfigurationsTable)
            .select(RepositoryConfigurationsTable.ortRunId)
            .where {
                RepositoryConfigurationsVulnerabilityResolutionsTable.vulnerabilityResolutionDefinitionId eq
                        definitionId
            }
            .map { it[RepositoryConfigurationsTable.ortRunId].value }
    }
}
