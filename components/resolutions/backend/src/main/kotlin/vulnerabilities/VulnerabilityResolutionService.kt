/*
 * Copyright (C) 2026 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.eclipse.apoapsis.ortserver.components.resolutions.vulnerabilities

import com.github.michaelbull.result.Result
import com.github.michaelbull.result.binding
import com.github.michaelbull.result.map
import com.github.michaelbull.result.toResultOr

import org.eclipse.apoapsis.ortserver.dao.blockingQuery
import org.eclipse.apoapsis.ortserver.model.RepositoryId
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolution
import org.eclipse.apoapsis.ortserver.model.runs.repository.VulnerabilityResolutionReason
import org.eclipse.apoapsis.ortserver.services.RepositoryService
import org.eclipse.apoapsis.ortserver.utils.logging.runBlocking

import org.jetbrains.exposed.v1.core.ResultRow
import org.jetbrains.exposed.v1.core.eq
import org.jetbrains.exposed.v1.jdbc.Database
import org.jetbrains.exposed.v1.jdbc.andWhere
import org.jetbrains.exposed.v1.jdbc.selectAll

class VulnerabilityResolutionService(
    private val db: Database,
    private val eventStore: VulnerabilityResolutionEventStore,
    private val repositoryService: RepositoryService
) {
    internal fun createResolution(
        repositoryId: RepositoryId,
        externalId: String,
        userId: String,
        reason: VulnerabilityResolutionReason,
        comment: String
    ): Result<Unit, VulnerabilityResolutionError> = db.blockingQuery {
        binding {
            validateRepositoryExists(repositoryId).bind()
            val state = getVulnerabilityResolutionStateOrEmpty(repositoryId, externalId)
            validateIsDeleted(state).bind()

            eventStore.appendEvent(
                VulnerabilityResolutionEvent(
                    repositoryId = repositoryId,
                    externalId = externalId,
                    version = state.version + 1,
                    payload = Created(
                        reason = reason,
                        comment = comment
                    ),
                    createdBy = userId
                )
            )
        }
    }

    internal fun updateResolution(
        repositoryId: RepositoryId,
        externalId: String,
        userId: String,
        reason: VulnerabilityResolutionReason?,
        comment: String?
    ): Result<Unit, VulnerabilityResolutionError> = db.blockingQuery {
        binding {
            validateRepositoryExists(repositoryId).bind()
            val state = getVulnerabilityResolutionStateOrEmpty(repositoryId, externalId)
            validateNotDeleted(state).bind()

            if (reason == null && comment == null) return@binding

            eventStore.appendEvent(
                VulnerabilityResolutionEvent(
                    repositoryId = repositoryId,
                    externalId = externalId,
                    version = state.version + 1,
                    payload = Updated(
                        reason = reason,
                        comment = comment
                    ),
                    createdBy = userId
                )
            )
        }
    }

    internal fun deleteResolution(
        repositoryId: RepositoryId,
        externalId: String,
        userId: String
    ): Result<Unit, VulnerabilityResolutionError> = db.blockingQuery {
        binding {
            validateRepositoryExists(repositoryId).bind()
            val state = getVulnerabilityResolutionStateOrEmpty(repositoryId, externalId)
            validateNotDeleted(state).bind()

            eventStore.appendEvent(
                VulnerabilityResolutionEvent(
                    repositoryId = repositoryId,
                    externalId = externalId,
                    version = state.version + 1,
                    payload = Deleted,
                    createdBy = userId
                )
            )
        }
    }

    internal fun getResolution(
        repositoryId: RepositoryId,
        externalId: String
    ): Result<VulnerabilityResolution, VulnerabilityResolutionError> = db.blockingQuery {
        binding {
            validateRepositoryExists(repositoryId).bind()

            val row = VulnerabilityResolutionsReadModel
                .selectAll()
                .where { VulnerabilityResolutionsReadModel.repositoryId eq repositoryId }
                .andWhere { VulnerabilityResolutionsReadModel.externalId eq externalId }
                .singleOrNull()
                .toResultOr { VulnerabilityResolutionError.ResolutionNotFound(externalId) }
                .bind()

            row.toVulnerabilityResolution()
        }
    }

    fun getResolutionsForRepository(
        repositoryId: RepositoryId
    ): Result<List<VulnerabilityResolution>, VulnerabilityResolutionError> = db.blockingQuery {
        binding {
            validateRepositoryExists(repositoryId).bind()

            VulnerabilityResolutionsReadModel
                .selectAll()
                .where { VulnerabilityResolutionsReadModel.repositoryId eq repositoryId }
                .map { it.toVulnerabilityResolution() }
        }
    }

    /**
     * Get the vulnerability resolution state for the given [repositoryId] and [externalId], or an empty state if none
     * exists.
     */
    private fun getVulnerabilityResolutionStateOrEmpty(
        repositoryId: RepositoryId,
        externalId: String
    ): VulnerabilityResolutionState =
        eventStore.getVulnerabilityResolution(repositoryId, externalId)
            ?: VulnerabilityResolutionState(repositoryId, externalId)

    /** Validate that the vulnerability resolution is deleted. */
    private fun validateIsDeleted(
        state: VulnerabilityResolutionState
    ): Result<VulnerabilityResolutionState, VulnerabilityResolutionError> =
        state.takeIf { it.isDeleted }.toResultOr {
            VulnerabilityResolutionError.InvalidState(
                "Vulnerability resolution for '${state.externalId}' already exists."
            )
        }

    /** Validate that the vulnerability resolution is not deleted. */
    private fun validateNotDeleted(
        state: VulnerabilityResolutionState
    ): Result<VulnerabilityResolutionState, VulnerabilityResolutionError> =
        state.takeUnless { it.isDeleted }.toResultOr {
            VulnerabilityResolutionError.ResolutionNotFound(state.externalId)
        }

    /** Validate that the repository exists. */
    private fun validateRepositoryExists(repositoryId: RepositoryId): Result<Unit, VulnerabilityResolutionError> =
        runBlocking {
            repositoryService.getRepository(repositoryId.value).toResultOr {
                VulnerabilityResolutionError.RepositoryNotFound(repositoryId)
            }.map { }
        }

    private fun ResultRow.toVulnerabilityResolution(): VulnerabilityResolution =
        VulnerabilityResolution(
            externalId = this[VulnerabilityResolutionsReadModel.externalId],
            reason = this[VulnerabilityResolutionsReadModel.reason],
            comment = this[VulnerabilityResolutionsReadModel.comment]
        )
}

sealed class VulnerabilityResolutionError(val message: String) {
    class InvalidState(message: String) : VulnerabilityResolutionError(message)

    class RepositoryNotFound(repositoryId: RepositoryId) :
        VulnerabilityResolutionError("Repository with ID '${repositoryId.value}' not found.")

    class ResolutionNotFound(externalId: String) :
        VulnerabilityResolutionError("Vulnerability resolution for '$externalId' not found.")
}
