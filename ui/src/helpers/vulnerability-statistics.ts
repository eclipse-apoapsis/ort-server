/*
 * Copyright (C) 2025 The ORT Server Authors (See <https://github.com/eclipse-apoapsis/ort-server/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

import {
  Cvss2,
  Cvss3P0,
  Cvss3P1,
  Cvss4P0,
  fromVector,
} from 'ae-cvss-calculator';
import {
  MultiScoreResult,
  SingleScoreResult,
} from 'ae-cvss-calculator/dist/types/src/CvssVector';

import { Vulnerability } from '@/api/requests/types.gen';

export type EpssData = {
  score: number;
  percentile: number;
};

type CvssData = {
  score: number;
  vector: string;
  version: string | null;
};

type CvssResultBase = {
  version: 'CVSS:2.0' | 'CVSS:3.0' | 'CVSS:3.1' | 'CVSS:4.0';
};

export type Cvss2to3Result = CvssResultBase & {
  version: 'CVSS:2.0' | 'CVSS:3.0' | 'CVSS:3.1';
  scores: MultiScoreResult;
};

type Cvss4Result = CvssResultBase & {
  version: 'CVSS:4.0';
  scores: SingleScoreResult;
  macroVector: Cvss4MacroVector;
};

type CvssScoreResult = Cvss2to3Result | Cvss4Result;

export type Cvss4MacroVector = {
  name: string;
  exploitability: string;
  complexity: string;
  vulnerableSystem: string;
  subsequentSystem: string;
  exploitation: string;
  sequrityRequirements: string;
};

function levelToText(level: number): string {
  if (level === 0) {
    return 'HIGH';
  } else if (level === 1) {
    return 'MEDIUM';
  } else if (level === 2) {
    return 'LOW';
  } else {
    return 'UNKNOWN';
  }
}

/**
 * Finds the EPSS metrics from a reference of the given vulnerability which reported
 * the highest score.
 *
 * @param vulnerability The vulnerability object containing references.
 * @returns The EPSS `score` and `percentile` of the reference that reports the highest score.
 */
export function findHighestEpssScore(
  vulnerability: Vulnerability
): EpssData | undefined {
  const epssReferences = extractEpssReferences(vulnerability);
  if (epssReferences.length === 0) {
    return undefined;
  }
  return epssReferences.reduce((prev, current) =>
    prev.score > current.score ? prev : current
  );
}

/**
 * Finds the CVSS metrics from a reference of the given vulnerability which reported
 * the highest score.
 *
 * @param vulnerability The vulnerability object containing references.
 * @returns The CVSS metrics of the reference that reports the highest score. The relevant
 *          metrics depend on the CVSS version (which is also returned).
 */
export function findHighestCvssScore(
  vulnerability: Vulnerability
): CvssScoreResult | undefined {
  const cvssReferences = extractCvssReferences(vulnerability);
  if (cvssReferences.length === 0) {
    return undefined;
  }
  const highestCvss = cvssReferences.reduce((prev, current) =>
    prev.score > current.score ? prev : current
  );

  switch (highestCvss.version) {
    case 'CVSS:2.0': {
      const cvss = new Cvss2(highestCvss.vector);
      return {
        version: 'CVSS:2.0',
        scores: cvss.calculateScores(true),
      };
    }
    case 'CVSS:3.0': {
      const cvss = new Cvss3P0(highestCvss.vector);
      return {
        version: 'CVSS:3.0',
        scores: cvss.calculateScores(true),
      };
    }
    case 'CVSS:3.1': {
      const cvss = new Cvss3P1(highestCvss.vector);
      return {
        version: 'CVSS:3.1',
        scores: cvss.calculateScores(true),
      };
    }
    // CVSS4.0 gives the results in a different format than 2.0, 3.0 and 3.1, by using
    // macrovectors to expose the different components of the CVSS vector.
    case 'CVSS:4.0': {
      const cvss = new Cvss4P0(highestCvss.vector);
      return {
        version: 'CVSS:4.0',
        scores: cvss.calculateScores(true),
        macroVector: {
          name: cvss.getMacroVector().toString(),
          exploitability: levelToText(
            cvss.getMacroVector().getEq1().getLevelAsInt()
          ),
          complexity: levelToText(
            cvss.getMacroVector().getEq2().getLevelAsInt()
          ),
          vulnerableSystem: levelToText(
            cvss.getMacroVector().getEq3().getLevelAsInt()
          ),
          subsequentSystem: levelToText(
            cvss.getMacroVector().getEq4().getLevelAsInt()
          ),
          exploitation: levelToText(
            cvss.getMacroVector().getEq5().getLevelAsInt()
          ),
          sequrityRequirements: levelToText(
            cvss.getMacroVector().getEq6().getLevelAsInt()
          ),
        },
      };
    }
    default:
      return undefined;
  }
}

/**
 * Extracts all valid EPSS scores and percentiles from the given vulnerability.
 *
 * @param vulnerability The vulnerability object containing references.
 * @returns An array of objects containing the EPSS `score` and `percentile`.
 */
function extractEpssReferences(vulnerability: Vulnerability): EpssData[] {
  // Filter out references that are not marked as EPSS or the score/vector is not a number,
  // to avoid unnecessary processing.
  const references = vulnerability.references.filter(
    (ref) =>
      ref.scoringSystem === 'epss' &&
      !isNaN(Number(ref.score)) &&
      !isNaN(Number(ref.vector))
  );
  const validReferences: EpssData[] = [];

  for (const reference of references) {
    const score = Number(reference.score);
    const percentile = Number(reference.vector); // For some reason, ORT returns the percentile as the vector.

    validReferences.push({
      score,
      percentile,
    });
  }
  return validReferences;
}

/**
 * Extracts all valid scores, CVSS vectors and their versions from the given vulnerability.
 *
 * @param vulnerability The vulnerability object containing references.
 * @returns An array of objects containing the CVSS `score`, `vector` and CVSS `version`.
 */
export function extractCvssReferences(
  vulnerability: Vulnerability
): CvssData[] {
  // Filter out references that do not have a vector or have an empty vector string, to
  // avoid unnecessary processing.
  const references = vulnerability.references.filter(
    (ref) => ref.vector && ref.vector.length > 0
  );
  const validReferences: CvssData[] = [];

  for (const reference of references) {
    if (reference.score && reference.vector) {
      const { isValid, version } = assessCvssVector(reference.vector);

      if (isValid) {
        validReferences.push({
          score: reference.score,
          vector: reference.vector,
          version,
        });
      }
    }
  }
  return validReferences;
}

/**
 * Use the fromVector function from the ae-cvss-calculator library to parse the CVSS vector string.
 *
 * @param vectorString The CVSS vector string to be assessed.
 * @returns An object containing `isValid` to indicate whether the vector string is a valid CVSS string;
 * and the assessed `version` of the CVSS vector, or null if not applicable.
 */
function assessCvssVector(vectorString: string): {
  isValid: boolean;
  version: string | null;
} {
  const parsedVector = fromVector(vectorString);

  if (!parsedVector) {
    return {
      isValid: false,
      version: null,
    };
  }

  // Use getVectorName() or constructor name to infer the version of the CVSS vector.
  let version: string | null = null;
  try {
    // If getVectorName returns something like "CVSS:3.1", use that.
    version =
      parsedVector.getVectorName?.() || parsedVector.constructor?.name || null;
  } catch {
    version = parsedVector.constructor?.name || null;
  }

  return {
    isValid: true,
    version,
  };
}
